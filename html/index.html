<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gRPC and Protobuf A01283525 Ian De La Garza: Proyecto de Captura y Procesamiento de Coordenadas de Objeto utilizando ROS, gRPC y REST-API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">gRPC and Protobuf A01283525 Ian De La Garza
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Proyecto de Captura y Procesamiento de Coordenadas de Objeto utilizando ROS, gRPC y REST-API </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Introducción</h1>
<p>Este proyecto tiene como objetivo principal capturar una imagen de la webcam, detectar un objeto verde en la imagen y calcular sus coordenadas X e Y. Utiliza el Robot Operating System (ROS), Python, C++, gRPC y REST-API para lograr esta funcionalidad.</p>
<h1><a class="anchor" id="steps_sec"></a>
Pasos del Proyecto</h1>
<ol type="1">
<li>Captura de imagen y detección del objeto verde utilizando un ROS Node en Python.</li>
<li>Creación de una librería en C++ para multiplicar las coordenadas por 100.</li>
<li>Integración de la librería C++ en el ROS Node para realizar la operación de multiplicación.</li>
<li>Publicación de las coordenadas resultantes en un ROS Topic junto con su timestamp.</li>
<li>Desarrollo de un Wrapper de gRPC para convertir el ROS Topic en un servicio RPC.</li>
<li>Implementación de un programa en C# que consume el servicio RPC y muestra las coordenadas en la terminal.</li>
<li>Uso de grpc-Gateway para exponer el servicio como un REST-API.</li>
<li>Adquisición de las coordenadas del objeto desde el nuevo REST-API utilizando Postman o Flask, y guardar los datos en un archivo JSON.</li>
</ol>
<h1><a class="anchor" id="lang_sec"></a>
Lenguajes y Plataformas</h1>
<p>El proyecto utiliza los siguientes lenguajes y plataformas:</p>
<ul>
<li>Python: como wrapper para mandar el topico de ros por medio de un serivicio RPC.</li>
<li>C++: para la captura de imagen y detección de objeto utilizando el ROS Node. Tambien la creación de la librería que realiza la multiplicación de las coordenadas.</li>
<li>ROS: como plataforma de desarrollo y comunicación entre los componentes.</li>
<li>gRPC: para la comunicación entre el ROS Node y el programa en Java a través de un servicio RPC.</li>
<li>Java: para el programa que consume el servicio RPC y muestra las coordenadas en la terminal.</li>
<li>grpc-Gateway junto con Go: para exponer el servicio como un REST-API.</li>
<li>Postman o Flask: para adquirir las coordenadas desde el REST-API y guardar los datos en un archivo JSON.</li>
<li>Protoc: para definir los mensajes y servicios utilizados en la comunicación gRPC.</li>
</ul>
<h1><a class="anchor" id="comp_sec"></a>
Componentes Principales</h1>
<p>Los componentes principales del proyecto son:</p>
<ul>
<li>ROS Node en C++: captura una imagen de la webcam, detecta el objeto verde y calcula las coordenadas X e Y.</li>
<li>Librería en C++: realiza la multiplicación de las coordenadas por 100.</li>
<li>Wrapper de gRPC: convierte el ROS Topic en un servicio RPC.</li>
<li>Protoc: define los mensajes y servicios utilizados en la comunicación gRPC.</li>
<li>Programa en C#: muestra las coordenadas del objeto en la terminal al consumir el servicio RPC.</li>
<li>grpc-Gateway: expone el servicio como un REST-API para obtener las coordenadas.</li>
<li>Postman o Flask: adquiere las coordenadas desde el REST-API y las guarda en un archivo JSON.</li>
</ul>
<h1><a class="anchor" id="steps_sec1"></a>
Paso 1: Captura de imagen y detección del objeto verde utilizando un ROS Node en C++</h1>
<h2><a class="anchor" id="code_sec"></a>
Código Fuente</h2>
<p>El código fuente para este paso se encuentra en el archivo <code><a class="el" href="enable__camera_8cpp.html">enable_camera.cpp</a></code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;ros/ros.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ros/console.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;geometry_msgs/PointStamped.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;image_transport/image_transport.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;opencv2/opencv.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cv_bridge/cv_bridge.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;aruco_ros/aruco_ros_utils.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="multiply_8h.html">pycam/multiply.h</a>&quot;</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="enable__camera_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    ros::init(argc, argv, <span class="stringliteral">&quot;webcam_publish_test&quot;</span>);</div>
<div class="line">    ros::NodeHandle nh;</div>
<div class="line">    image_transport::ImageTransport it(nh);</div>
<div class="line">    image_transport::Publisher pub = it.advertise(<span class="stringliteral">&quot;camera/image&quot;</span>, 1);</div>
<div class="line">    image_transport::Publisher marker_pub = it.advertise(<span class="stringliteral">&quot;camera/marker_image&quot;</span>, 1);</div>
<div class="line">    ros::Publisher marker_center_pub = nh.advertise&lt;geometry_msgs::PointStamped&gt;(<span class="stringliteral">&quot;camera/marker_center&quot;</span>, 1);</div>
<div class="line">    ros::Rate rate(30);</div>
<div class="line">    cv::VideoCapture cap(</div>
<div class="line">        <span class="stringliteral">&quot;nvarguscamerasrc ! video/x-raw(memory:NVMM), width=(int)720, height=(int)480,format=(string)NV12, framerate=(fraction)30/1 ! nvvidconv ! video/x-raw, format=(string)BGRx ! videoconvert !  appsink&quot;</span>, </div>
<div class="line">        cv::CAP_GSTREAMER);</div>
<div class="line">    <span class="keywordflow">if</span> (!cap.isOpened()) {</div>
<div class="line">        ROS_ERROR(<span class="stringliteral">&quot;Could not open camera&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    } </div>
<div class="line">    <span class="keywordtype">bool</span> stuff = cap.set(cv::CAP_PROP_FPS, 30);</div>
<div class="line">    aruco::CameraParameters camParam = aruco::CameraParameters();</div>
<div class="line">    cv::Mat frame, frame2;</div>
<div class="line">    aruco::MarkerDetector mDetector;</div>
<div class="line">    <span class="keywordtype">float</span> min_marker_size; <span class="comment">// percentage of image area</span></div>
<div class="line">    nh.param&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;min_marker_size&quot;</span>, min_marker_size, 0.01);</div>
<div class="line">    std::vector&lt;aruco::Marker&gt; markers;</div>
<div class="line">    mDetector.setDetectionMode(aruco::DM_VIDEO_FAST, min_marker_size);</div>
<div class="line">    <span class="keywordflow">while</span> (ros::ok()) {</div>
<div class="line">        markers.clear();</div>
<div class="line">        cap &gt;&gt; frame;</div>
<div class="line">        <span class="keywordflow">if</span> (frame.rows) {</div>
<div class="line">            <span class="comment">// resize image to 640x480</span></div>
<div class="line">            cv::resize(frame, frame, cv::Size(640, 480));</div>
<div class="line">             <span class="comment">//make frame sharper</span></div>
<div class="line">            cv::GaussianBlur(frame, frame2, cv::Size(0, 0), 3);</div>
<div class="line">            cv::addWeighted(frame, 1.5, frame2, -0.6, 0, frame);</div>
<div class="line">            cv::resize(frame, frame2, cv::Size(320, 240));</div>
<div class="line">            <span class="comment">// detect markers</span></div>
<div class="line">            sensor_msgs::ImagePtr msg = cv_bridge::CvImage(std_msgs::Header(), <span class="stringliteral">&quot;bgr8&quot;</span>, frame2).toImageMsg();</div>
<div class="line">            pub.publish(msg);</div>
<div class="line">            mDetector.detect(frame, markers, camParam);</div>
<div class="line">            <span class="comment">// for each marker, draw info and its boundaries in the image</span></div>
<div class="line">            <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; markers.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                markers[i].draw(frame, cv::Scalar(0, 0, 255), 2);</div>
<div class="line">                <span class="comment">//get center of marker</span></div>
<div class="line">                cv::Point2f center = markers[i].getCenter();</div>
<div class="line">                <span class="comment">//publish center of marker</span></div>
<div class="line">                <span class="keywordtype">int</span> x = center.x;</div>
<div class="line">                <span class="keywordtype">int</span> y = center.y;</div>
<div class="line">                <span class="comment">//call multiply .so function</span></div>
<div class="line">                <a class="code hl_function" href="multiply_8cpp.html#ad8d9ee68852e46ad9115ffae3bb0bc0b">multiply</a>(&amp;x, &amp;y);</div>
<div class="line">                geometry_msgs::PointStamped marker_center;</div>
<div class="line">                marker_center.header.stamp = ros::Time::now();</div>
<div class="line">                marker_center.point.x = x;</div>
<div class="line">                marker_center.point.y = y;</div>
<div class="line">                marker_center_pub.publish(marker_center);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span>(markers.size() &gt; 0)</div>
<div class="line">            {</div>
<div class="line">                cv::resize(frame, frame2, cv::Size(320, 240));</div>
<div class="line">                marker_pub.publish(cv_bridge::CvImage(std_msgs::Header(), <span class="stringliteral">&quot;bgr8&quot;</span>, frame2).toImageMsg());</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        rate.sleep();</div>
<div class="line">    }</div>
<div class="line">    cap.release();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aenable__camera_8cpp_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="enable__camera_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdoc">Función principal.</div><div class="ttdef"><b>Definition</b> enable_camera.cpp:19</div></div>
<div class="ttc" id="amultiply_8cpp_html_ad8d9ee68852e46ad9115ffae3bb0bc0b"><div class="ttname"><a href="multiply_8cpp.html#ad8d9ee68852e46ad9115ffae3bb0bc0b">multiply</a></div><div class="ttdeci">void multiply(int *x, int *y)</div><div class="ttdoc">Multiplica dos enteros por 100.</div><div class="ttdef"><b>Definition</b> multiply.cpp:18</div></div>
<div class="ttc" id="amultiply_8h_html"><div class="ttname"><a href="multiply_8h.html">multiply.h</a></div><div class="ttdoc">Archivo de cabecera para la función multiplicar.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="description_sec"></a>
Descripción del Código</h2>
<p>En esta etapa, inicializamos un nodo ROS llamado "webcam_publish_test" y configuramos varios publicadores y suscriptores. El código entonces comienza a capturar imágenes desde la webcam utilizando OpenCV y detecta marcadores ArUco en la imagen.</p>
<p>Cada vez que se captura una imagen, se publica en el tópico "camera/image". Si se detectan marcadores ArUco en la imagen, se dibujan en la imagen y se publica en el tópico "camera/marker_image". El centro del marcador detectado se calcula, se multiplica por 100 y se publica en el tópico "camera/marker_center".</p>
<p>La detección de marcadores ArUco se realiza utilizando la biblioteca ArUco. Los marcadores son objetos cuadrados en el mundo real que pueden ser fácilmente detectados y identificados en imágenes. Son útiles para la calibración de cámaras y la estimación de la pose en aplicaciones de realidad aumentada. El código detecta los marcadores utilizando el modo de detección rápido de video (<code>DM_VIDEO_FAST</code>) con un tamaño mínimo de marcador especificado por el parámetro "min_marker_size".</p>
<p>El código continúa en un bucle hasta que se detiene el nodo ROS. Luego, libera la cámara y finaliza.</p>
<h2><a class="anchor" id="usage_sec1"></a>
Uso del Código</h2>
<p>Para usar este código, debses tener una webcam compatible y un marcador ArUco visible en la imagen de la webcam. Puedes ajustar el tamaño mínimo del marcador y la frecuencia de captura de imágenes cambiando los parámetros "min_marker_size" y "rate", respectivamente.</p>
<h1><a class="anchor" id="steps_sec2"></a>
Paso 2: Creación de una librería en C++ para multiplicar las coordenadas por 100</h1>
<h2><a class="anchor" id="code_sec"></a>
Código Fuente</h2>
<p>El código fuente para este paso se encuentra en los archivos <code><a class="el" href="multiply_8h.html" title="Archivo de cabecera para la función multiplicar.">multiply.h</a></code> y <code><a class="el" href="multiply_8cpp.html" title="Archivo que contiene la definición de la función multiplicar.">multiply.cpp</a></code>.</p>
<p><code><a class="el" href="multiply_8cpp.html" title="Archivo que contiene la definición de la función multiplicar.">multiply.cpp</a></code> </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="multiply_8cpp.html#ad8d9ee68852e46ad9115ffae3bb0bc0b">multiply</a>(<span class="keywordtype">int</span>* x, <span class="keywordtype">int</span>* y) {</div>
<div class="line">        *x *= 100;</div>
<div class="line">        *y *= 100;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> <code><a class="el" href="multiply_8h.html" title="Archivo de cabecera para la función multiplicar.">multiply.h</a></code> </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef __cplusplus</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="multiply_8cpp.html#ad8d9ee68852e46ad9115ffae3bb0bc0b">multiply</a>(<span class="keywordtype">int</span>* a, <span class="keywordtype">int</span>* b);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef __cplusplus</span></div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><h2><a class="anchor" id="description_sec"></a>
Descripción del Código</h2>
<p>En esta etapa, creamos una librería en C++ que proporciona una función para multiplicar las coordenadas por 100.</p>
<p>El archivo <code><a class="el" href="multiply_8h.html" title="Archivo de cabecera para la función multiplicar.">multiply.h</a></code> contiene la declaración de la función <code>multiply</code> que toma dos punteros a enteros y multiplica sus valores por 100.</p>
<p>El archivo <code><a class="el" href="multiply_8cpp.html" title="Archivo que contiene la definición de la función multiplicar.">multiply.cpp</a></code> contiene la implementación de la función <code>multiply</code>. En esta implementación, los valores apuntados por los punteros se multiplican por 100.</p>
<h1><a class="anchor" id="steps_sec3"></a>
Paso 3: Integración de la librería C++ en el ROS Node para realizar la operación de multiplicación.</h1>
<h2><a class="anchor" id="usage_sec2"></a>
Uso del Código</h2>
<p>Para utilizar esta librería en tu proyecto, debes incluir el archivo de encabezado <code><a class="el" href="multiply_8h.html" title="Archivo de cabecera para la función multiplicar.">multiply.h</a></code> en tus archivos fuente donde necesites utilizar la función <code>multiply</code>. Luego, enlaza tu proyecto con el archivo objeto generado a partir del archivo fuente <code><a class="el" href="multiply_8cpp.html" title="Archivo que contiene la definición de la función multiplicar.">multiply.cpp</a></code>.</p>
<p>Puedes llamar a la función <code>multiply</code> pasando los valores que deseas multiplicar por 100 como argumentos. Los valores se multiplicarán directamente en su ubicación de memoria. Por lo tanto, no es necesario devolver un valor de la función. Por ejemplo en <a class="el" href="enable__camera_8cpp.html">enable_camera.cpp</a> su puede ver como se utiliza la librería:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> x = center.x;</div>
<div class="line"><span class="keywordtype">int</span> y = center.y;</div>
<div class="line"><span class="comment">//call multiply .so function</span></div>
<div class="line"><a class="code hl_function" href="multiply_8cpp.html#ad8d9ee68852e46ad9115ffae3bb0bc0b">multiply</a>(&amp;x, &amp;y);</div>
</div><!-- fragment --><p> Para lograr que el codigo usara el .so al compilar se tuvo que agregar lo siguiente en el <code>CMakelists.txt</code>: </p><div class="fragment"><div class="line">include_directories(</div>
<div class="line">    ${CMAKE_CURRENT_SOURCE_DIR}/include</div>
<div class="line">)</div>
</div><!-- fragment --><div class="fragment"><div class="line">target_link_libraries(enable_camera ${OpenCV_LIBRARIES} ${catkin_LIBRARIES} ${CMAKE_CURRENT_SOURCE_DIR}/lib/libmultiply.so)</div>
</div><!-- fragment --><div class="fragment"><div class="line">install(DIRECTORY include/${PROJECT_NAME}/</div>
<div class="line">  DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}</div>
<div class="line">  FILES_MATCHING PATTERN &quot;*.h&quot;</div>
<div class="line">  PATTERN &quot;.svn&quot; EXCLUDE</div>
<div class="line">)</div>
</div><!-- fragment --><h2><a class="anchor" id="python_hyperlink"></a>
Como utilizar una libreria compartida (.so) en python</h2>
<p>Si le interesa saber como utilizar un .so en python puede ver la siguiente pagina <a class="el" href="agregar_so_python.html">Agregar un archivo de biblioteca compartida (.so) a Python utilizando ctypes</a></p>
<h1><a class="anchor" id="steps_sec4"></a>
Paso 4: Publicación de las coordenadas resultantes en un ROS Topic junto con su timestamp</h1>
<p>En este paso del proyecto, se publican las coordenadas resultantes en un ROS Topic junto con su timestamp. Esto permite que otros nodos de ROS puedan suscribirse a este topic y obtener las coordenadas actualizadas del objeto.</p>
<p>El proceso de publicación de las coordenadas se realiza utilizando el framework ROS y su sistema de publicación y suscripción de mensajes. A continuación, se describe el flujo de trabajo para realizar esta tarea:</p>
<ol type="1">
<li>Definir un mensaje: Antes de publicar las coordenadas, se debe definir un mensaje personalizado en ROS que contenga los campos necesarios para almacenar las coordenadas X e Y, así como el timestamp correspondiente. Para ello se escogio un mensaje de tipo PointStamped que ya viene definido en ROS. Este mensaje contiene los campos necesarios para almacenar las coordenadas X e Y, así como el timestamp correspondiente.</li>
<li>Crear un publicador: En el nodo responsable de la detección y cálculo de las coordenadas, se debe crear un objeto publicador que esté configurado para publicar mensajes en el topic específico. El publicador se crea utilizando la biblioteca de ROS y se especifica el tipo de mensaje que se publicará (el mensajes definido en el paso anterior). Esto se puede ver en el archivo <code><a class="el" href="enable__camera_8cpp.html">enable_camera.cpp</a></code>: <div class="fragment"><div class="line">ros::Publisher marker_center_pub = nh.advertise&lt;geometry_msgs::PointStamped&gt;(<span class="stringliteral">&quot;camera/marker_center&quot;</span>, 1);</div>
</div><!-- fragment --></li>
<li>Actualizar y publicar las coordenadas: En cada iteración del bucle de detección y cálculo de coordenadas, se actualizan los valores de las coordenadas y se establece el timestamp actual. A continuación, se empaquetan los valores de las coordenadas y el timestamp en un objeto de mensaje y se publica a través del publicador creado en el paso anterior. Esto se puede ver en el archivo <code><a class="el" href="enable__camera_8cpp.html">enable_camera.cpp</a></code>: <div class="fragment"><div class="line">            <span class="comment">// for each marker, draw info and its boundaries in the image</span></div>
<div class="line">            <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; markers.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                markers[i].draw(frame, cv::Scalar(0, 0, 255), 2);</div>
<div class="line">                <span class="comment">//get center of marker</span></div>
<div class="line">                cv::Point2f center = markers[i].getCenter();</div>
<div class="line">                <span class="comment">//publish center of marker</span></div>
<div class="line">                <span class="keywordtype">int</span> x = center.x;</div>
<div class="line">                <span class="keywordtype">int</span> y = center.y;</div>
<div class="line">                <span class="comment">//call multiply .so function</span></div>
<div class="line">                <a class="code hl_function" href="multiply_8cpp.html#ad8d9ee68852e46ad9115ffae3bb0bc0b">multiply</a>(&amp;x, &amp;y);</div>
<div class="line">                geometry_msgs::PointStamped marker_center;</div>
<div class="line">                marker_center.header.stamp = ros::Time::now();</div>
<div class="line">                marker_center.point.x = x;</div>
<div class="line">                marker_center.point.y = y;</div>
<div class="line">                marker_center_pub.publish(marker_center);</div>
<div class="line">            }</div>
</div><!-- fragment --> Una vez que las coordenadas se publican en el topic, otros nodos de ROS pueden suscribirse a este topic y recibir las coordenadas actualizadas en tiempo real. Esto permite la integración con otros componentes del sistema o la realización de acciones específicas basadas en las coordenadas detectadas. </li>
</ol>
<h1><a class="anchor" id="steps_sec5"></a>
Paso 5: Desarrollo de un Wrapper de gRPC para convertir el ROS Topic en un servicio RPC</h1>
<p>En este paso del proyecto, se desarrolla un Wrapper de gRPC que convierte el ROS Topic de las coordenadas en un servicio RPC. Esto permite la comunicación entre el nodo ROS y otros programas o sistemas que pueden consumir el servicio RPC.</p>
<p>El Wrapper de gRPC se implementa utilizando el lenguaje de programación Python y las bibliotecas de gRPC y ROS. A continuación, se describe el flujo de trabajo para convertir el ROS Topic en un servicio RPC utilizando el Wrapper de gRPC:</p><ol type="1">
<li>Definir el servicio RPC: Antes de implementar el Wrapper de gRPC, se debe definir el servicio RPC que se proporcionará. El servicio debe tener una interfaz clara que especifique los métodos que estarán disponibles y los tipos de datos que se utilizarán. Para esto, se utiliza la herramienta <code>protoc</code> para definir el mensaje enviado por gRPC. El archivo <code>.proto</code> contiene la definición del mensaje y se utiliza para generar los archivos de código necesarios. A continuación se puede observar el archivo <code>.proto</code> usado en este proyecto <code><a class="el" href="proto_2PositionService_8proto.html">pycam/proto/PositionService.proto</a></code>: <pre class="fragment"> syntax = "proto3";
 
 package object_position;
 message Empty {
 }
  // El mensaje de respuesta que contiene la posición
  message Position {
    double x = 1;
    double y = 2;
    int64 timestamp = 3; // Este campo representa el timestamp del mensaje.
  }
 
  // La definición del servicio
  service PositionService {
    // Envía una posición
    rpc SendPosition (Empty) returns (Position);
  }
</pre></li>
<li>Generar los archivos de código: Utilizando el compilador de gRPC y el archivo <code>.proto</code>, se deben generar los archivos de código necesarios para implementar el servicio RPC. Estos archivos incluyen los stubs del cliente y del servidor, así como los mensajes definidos en el servicio. Para generar los archivos se utilizo el siguiente comando: <pre class="fragment">$ python -m grpc_tools.protoc --python_out=. --grpc_python_out=. nombre_del_archivo.proto
</pre> Y obtuvimos los archivos <code><a class="el" href="PositionService__pb2_8py.html">PositionService_pb2.py</a></code> y <code><a class="el" href="PositionService__pb2__grpc_8py.html">PositionService_pb2_grpc.py</a></code> que se pueden ver en la carpeta <code>pycam/src/</code>.</li>
<li>Configurar y ejecutar el servidor gRPC: Se configura el servidor gRPC para que escuche en un puerto específico y acepte conexiones entrantes. Luego, se agrega el servidor gRPC al nodo ROS para que se ejecute como parte del nodo. Se puede observar el codigo implementado en el archivo <code><a class="el" href="grpc__wrapper_8py.html">grpc_wrapper.py</a></code>: Una vez que se ha implementado el Wrapper de gRPC y configurado el servidor, otros programas o sistemas pueden consumir el servicio RPC para obtener las coordenadas del objeto. Esto permite la integración con diferentes plataformas y la comunicación eficiente de las coordenadas. </li>
</ol>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
