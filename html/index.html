<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gRPC and Protobuf A01283525 Ian De La Garza: Proyecto de Captura y Procesamiento de Coordenadas de Objeto utilizando ROS, gRPC y REST-API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">gRPC and Protobuf A01283525 Ian De La Garza
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Proyecto de Captura y Procesamiento de Coordenadas de Objeto utilizando ROS, gRPC y REST-API </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Introducción</h1>
<p>Este proyecto tiene como objetivo principal capturar una imagen de la webcam, detectar un objeto verde en la imagen y calcular sus coordenadas X e Y. Utiliza el Robot Operating System (ROS), Python, C++, gRPC y REST-API para lograr esta funcionalidad.</p>
<p>Se puede un video del proyecto funcionando en <a href="https://drive.google.com/file/d/1gfKTAAFY7mNjZSFFG5LzwTAjmISHOkOd/view?usp=sharing">https://drive.google.com/file/d/1gfKTAAFY7mNjZSFFG5LzwTAjmISHOkOd/view?usp=sharing</a></p>
<h1><a class="anchor" id="steps_sec"></a>
Pasos del Proyecto</h1>
<ol type="1">
<li>Captura de imagen y detección del objeto verde utilizando un ROS Node en Python.</li>
<li>Creación de una librería en C++ para multiplicar las coordenadas por 100.</li>
<li>Integración de la librería C++ en el ROS Node para realizar la operación de multiplicación.</li>
<li>Publicación de las coordenadas resultantes en un ROS Topic junto con su timestamp.</li>
<li>Desarrollo de un Wrapper de gRPC para convertir el ROS Topic en un servicio RPC.</li>
<li>Implementación de un programa en C# que consume el servicio RPC y muestra las coordenadas en la terminal.</li>
<li>Uso de grpc-Gateway para exponer el servicio como un REST-API.</li>
<li>Adquisición de las coordenadas del objeto desde el nuevo REST-API utilizando Postman o Flask, y guardar los datos en un archivo JSON.</li>
</ol>
<h1><a class="anchor" id="lang_sec"></a>
Lenguajes y Plataformas</h1>
<p>El proyecto utiliza los siguientes lenguajes y plataformas:</p>
<ul>
<li>Python: como wrapper para mandar el topico de ros por medio de un serivicio RPC.</li>
<li>C++: para la captura de imagen y detección de objeto utilizando el ROS Node. Tambien la creación de la librería que realiza la multiplicación de las coordenadas.</li>
<li>ROS: como plataforma de desarrollo y comunicación entre los componentes.</li>
<li>gRPC: para la comunicación entre el ROS Node y el programa en Java a través de un servicio RPC.</li>
<li>Java: para el programa que consume el servicio RPC y muestra las coordenadas en la terminal.</li>
<li>grpc-Gateway junto con Go: para exponer el servicio como un REST-API.</li>
<li>Postman o Flask: para adquirir las coordenadas desde el REST-API y guardar los datos en un archivo JSON.</li>
<li>Protoc: para definir los mensajes y servicios utilizados en la comunicación gRPC.</li>
</ul>
<h1><a class="anchor" id="comp_sec"></a>
Componentes Principales</h1>
<p>Los componentes principales del proyecto son:</p>
<ul>
<li>ROS Node en C++: captura una imagen de la webcam, detecta el objeto verde y calcula las coordenadas X e Y.</li>
<li>Librería en C++: realiza la multiplicación de las coordenadas por 100.</li>
<li>Wrapper de gRPC: convierte el ROS Topic en un servicio RPC.</li>
<li>Protoc: define los mensajes y servicios utilizados en la comunicación gRPC.</li>
<li>Programa en C#: muestra las coordenadas del objeto en la terminal al consumir el servicio RPC.</li>
<li>grpc-Gateway: expone el servicio como un REST-API para obtener las coordenadas.</li>
<li>Postman o Flask: adquiere las coordenadas desde el REST-API y las guarda en un archivo JSON.</li>
</ul>
<h1><a class="anchor" id="steps_sec1"></a>
Paso 1: Captura de imagen y detección del objeto verde utilizando un ROS Node en C++</h1>
<h2><a class="anchor" id="code_sec"></a>
Código Fuente</h2>
<p>El código fuente para este paso se encuentra en el archivo <code><a class="el" href="enable__camera_8cpp.html">enable_camera.cpp</a></code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;ros/ros.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ros/console.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;geometry_msgs/PointStamped.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;image_transport/image_transport.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;opencv2/opencv.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cv_bridge/cv_bridge.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;aruco_ros/aruco_ros_utils.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="multiply_8h.html">pycam/multiply.h</a>&quot;</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="enable__camera_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    ros::init(argc, argv, <span class="stringliteral">&quot;webcam_publish_test&quot;</span>);</div>
<div class="line">    ros::NodeHandle nh;</div>
<div class="line">    image_transport::ImageTransport it(nh);</div>
<div class="line">    image_transport::Publisher pub = it.advertise(<span class="stringliteral">&quot;camera/image&quot;</span>, 1);</div>
<div class="line">    image_transport::Publisher marker_pub = it.advertise(<span class="stringliteral">&quot;camera/marker_image&quot;</span>, 1);</div>
<div class="line">    ros::Publisher marker_center_pub = nh.advertise&lt;geometry_msgs::PointStamped&gt;(<span class="stringliteral">&quot;camera/marker_center&quot;</span>, 1);</div>
<div class="line">    ros::Rate rate(30);</div>
<div class="line">    cv::VideoCapture cap(</div>
<div class="line">        <span class="stringliteral">&quot;nvarguscamerasrc ! video/x-raw(memory:NVMM), width=(int)720, height=(int)480,format=(string)NV12, framerate=(fraction)30/1 ! nvvidconv ! video/x-raw, format=(string)BGRx ! videoconvert !  appsink&quot;</span>, </div>
<div class="line">        cv::CAP_GSTREAMER);</div>
<div class="line">    <span class="keywordflow">if</span> (!cap.isOpened()) {</div>
<div class="line">        ROS_ERROR(<span class="stringliteral">&quot;Could not open camera&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    } </div>
<div class="line">    <span class="keywordtype">bool</span> stuff = cap.set(cv::CAP_PROP_FPS, 30);</div>
<div class="line">    aruco::CameraParameters camParam = aruco::CameraParameters();</div>
<div class="line">    cv::Mat frame, frame2;</div>
<div class="line">    aruco::MarkerDetector mDetector;</div>
<div class="line">    <span class="keywordtype">float</span> min_marker_size; <span class="comment">// percentage of image area</span></div>
<div class="line">    nh.param&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;min_marker_size&quot;</span>, min_marker_size, 0.01);</div>
<div class="line">    std::vector&lt;aruco::Marker&gt; markers;</div>
<div class="line">    mDetector.setDetectionMode(aruco::DM_VIDEO_FAST, min_marker_size);</div>
<div class="line">    <span class="keywordflow">while</span> (ros::ok()) {</div>
<div class="line">        markers.clear();</div>
<div class="line">        cap &gt;&gt; frame;</div>
<div class="line">        <span class="keywordflow">if</span> (frame.rows) {</div>
<div class="line">            <span class="comment">// resize image to 640x480</span></div>
<div class="line">            cv::resize(frame, frame, cv::Size(640, 480));</div>
<div class="line">             <span class="comment">//make frame sharper</span></div>
<div class="line">            cv::GaussianBlur(frame, frame2, cv::Size(0, 0), 3);</div>
<div class="line">            cv::addWeighted(frame, 1.5, frame2, -0.6, 0, frame);</div>
<div class="line">            cv::resize(frame, frame2, cv::Size(320, 240));</div>
<div class="line">            <span class="comment">// detect markers</span></div>
<div class="line">            sensor_msgs::ImagePtr msg = cv_bridge::CvImage(std_msgs::Header(), <span class="stringliteral">&quot;bgr8&quot;</span>, frame2).toImageMsg();</div>
<div class="line">            pub.publish(msg);</div>
<div class="line">            mDetector.detect(frame, markers, camParam);</div>
<div class="line">            <span class="comment">// for each marker, draw info and its boundaries in the image</span></div>
<div class="line">            <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; markers.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                markers[i].draw(frame, cv::Scalar(0, 0, 255), 2);</div>
<div class="line">                <span class="comment">//get center of marker</span></div>
<div class="line">                cv::Point2f center = markers[i].getCenter();</div>
<div class="line">                <span class="comment">//publish center of marker</span></div>
<div class="line">                <span class="keywordtype">int</span> x = center.x;</div>
<div class="line">                <span class="keywordtype">int</span> y = center.y;</div>
<div class="line">                <span class="comment">//call multiply .so function</span></div>
<div class="line">                <a class="code hl_function" href="multiply_8cpp.html#ad8d9ee68852e46ad9115ffae3bb0bc0b">multiply</a>(&amp;x, &amp;y);</div>
<div class="line">                geometry_msgs::PointStamped marker_center;</div>
<div class="line">                marker_center.header.stamp = ros::Time::now();</div>
<div class="line">                marker_center.point.x = x;</div>
<div class="line">                marker_center.point.y = y;</div>
<div class="line">                marker_center_pub.publish(marker_center);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span>(markers.size() &gt; 0)</div>
<div class="line">            {</div>
<div class="line">                cv::resize(frame, frame2, cv::Size(320, 240));</div>
<div class="line">                marker_pub.publish(cv_bridge::CvImage(std_msgs::Header(), <span class="stringliteral">&quot;bgr8&quot;</span>, frame2).toImageMsg());</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        rate.sleep();</div>
<div class="line">    }</div>
<div class="line">    cap.release();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aenable__camera_8cpp_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="enable__camera_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdoc">Función principal.</div><div class="ttdef"><b>Definition</b> enable_camera.cpp:19</div></div>
<div class="ttc" id="amultiply_8cpp_html_ad8d9ee68852e46ad9115ffae3bb0bc0b"><div class="ttname"><a href="multiply_8cpp.html#ad8d9ee68852e46ad9115ffae3bb0bc0b">multiply</a></div><div class="ttdeci">void multiply(int *x, int *y)</div><div class="ttdoc">Multiplica dos enteros por 100.</div><div class="ttdef"><b>Definition</b> multiply.cpp:18</div></div>
<div class="ttc" id="amultiply_8h_html"><div class="ttname"><a href="multiply_8h.html">multiply.h</a></div><div class="ttdoc">Archivo de cabecera para la función multiplicar.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="description_sec"></a>
Descripción del Código</h2>
<p>En esta etapa, inicializamos un nodo ROS llamado "webcam_publish_test" y configuramos varios publicadores y suscriptores. El código entonces comienza a capturar imágenes desde la webcam utilizando OpenCV y detecta marcadores ArUco en la imagen.</p>
<p>Cada vez que se captura una imagen, se publica en el tópico "camera/image". Si se detectan marcadores ArUco en la imagen, se dibujan en la imagen y se publica en el tópico "camera/marker_image". El centro del marcador detectado se calcula, se multiplica por 100 y se publica en el tópico "camera/marker_center".</p>
<p>La detección de marcadores ArUco se realiza utilizando la biblioteca ArUco. Los marcadores son objetos cuadrados en el mundo real que pueden ser fácilmente detectados y identificados en imágenes. Son útiles para la calibración de cámaras y la estimación de la pose en aplicaciones de realidad aumentada. El código detecta los marcadores utilizando el modo de detección rápido de video (<code>DM_VIDEO_FAST</code>) con un tamaño mínimo de marcador especificado por el parámetro "min_marker_size".</p>
<p>El código continúa en un bucle hasta que se detiene el nodo ROS. Luego, libera la cámara y finaliza.</p>
<h2><a class="anchor" id="usage_sec1"></a>
Uso del Código</h2>
<p>Para usar este código, debses tener una webcam compatible y un marcador ArUco visible en la imagen de la webcam. Puedes ajustar el tamaño mínimo del marcador y la frecuencia de captura de imágenes cambiando los parámetros "min_marker_size" y "rate", respectivamente.</p>
<h1><a class="anchor" id="steps_sec2"></a>
Paso 2: Creación de una librería en C++ para multiplicar las coordenadas por 100</h1>
<h2><a class="anchor" id="code_sec"></a>
Código Fuente</h2>
<p>El código fuente para este paso se encuentra en los archivos <code><a class="el" href="multiply_8h.html" title="Archivo de cabecera para la función multiplicar.">multiply.h</a></code> y <code><a class="el" href="multiply_8cpp.html" title="Archivo que contiene la definición de la función multiplicar.">multiply.cpp</a></code>.</p>
<p><code><a class="el" href="multiply_8cpp.html" title="Archivo que contiene la definición de la función multiplicar.">multiply.cpp</a></code> </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="multiply_8cpp.html#ad8d9ee68852e46ad9115ffae3bb0bc0b">multiply</a>(<span class="keywordtype">int</span>* x, <span class="keywordtype">int</span>* y) {</div>
<div class="line">        *x *= 100;</div>
<div class="line">        *y *= 100;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> <code><a class="el" href="multiply_8h.html" title="Archivo de cabecera para la función multiplicar.">multiply.h</a></code> </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef __cplusplus</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="multiply_8cpp.html#ad8d9ee68852e46ad9115ffae3bb0bc0b">multiply</a>(<span class="keywordtype">int</span>* a, <span class="keywordtype">int</span>* b);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef __cplusplus</span></div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><h2><a class="anchor" id="description_sec"></a>
Descripción del Código</h2>
<p>En esta etapa, creamos una librería en C++ que proporciona una función para multiplicar las coordenadas por 100.</p>
<p>El archivo <code><a class="el" href="multiply_8h.html" title="Archivo de cabecera para la función multiplicar.">multiply.h</a></code> contiene la declaración de la función <code>multiply</code> que toma dos punteros a enteros y multiplica sus valores por 100.</p>
<p>El archivo <code><a class="el" href="multiply_8cpp.html" title="Archivo que contiene la definición de la función multiplicar.">multiply.cpp</a></code> contiene la implementación de la función <code>multiply</code>. En esta implementación, los valores apuntados por los punteros se multiplican por 100.</p>
<h1><a class="anchor" id="steps_sec3"></a>
Paso 3: Integración de la librería C++ en el ROS Node para realizar la operación de multiplicación.</h1>
<h2><a class="anchor" id="usage_sec2"></a>
Uso del Código</h2>
<p>Para utilizar esta librería en tu proyecto, debes incluir el archivo de encabezado <code><a class="el" href="multiply_8h.html" title="Archivo de cabecera para la función multiplicar.">multiply.h</a></code> en tus archivos fuente donde necesites utilizar la función <code>multiply</code>. Luego, enlaza tu proyecto con el archivo objeto generado a partir del archivo fuente <code><a class="el" href="multiply_8cpp.html" title="Archivo que contiene la definición de la función multiplicar.">multiply.cpp</a></code>.</p>
<p>Puedes llamar a la función <code>multiply</code> pasando los valores que deseas multiplicar por 100 como argumentos. Los valores se multiplicarán directamente en su ubicación de memoria. Por lo tanto, no es necesario devolver un valor de la función. Por ejemplo en <a class="el" href="enable__camera_8cpp.html">enable_camera.cpp</a> su puede ver como se utiliza la librería:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> x = center.x;</div>
<div class="line"><span class="keywordtype">int</span> y = center.y;</div>
<div class="line"><span class="comment">//call multiply .so function</span></div>
<div class="line"><a class="code hl_function" href="multiply_8cpp.html#ad8d9ee68852e46ad9115ffae3bb0bc0b">multiply</a>(&amp;x, &amp;y);</div>
</div><!-- fragment --><p> Para lograr que el codigo usara el .so al compilar se tuvo que agregar lo siguiente en el <code>CMakelists.txt</code>: </p><div class="fragment"><div class="line">include_directories(</div>
<div class="line">    ${CMAKE_CURRENT_SOURCE_DIR}/include</div>
<div class="line">)</div>
</div><!-- fragment --><div class="fragment"><div class="line">target_link_libraries(enable_camera ${OpenCV_LIBRARIES} ${catkin_LIBRARIES} ${CMAKE_CURRENT_SOURCE_DIR}/lib/libmultiply.so)</div>
</div><!-- fragment --><div class="fragment"><div class="line">install(DIRECTORY include/${PROJECT_NAME}/</div>
<div class="line">  DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}</div>
<div class="line">  FILES_MATCHING PATTERN &quot;*.h&quot;</div>
<div class="line">  PATTERN &quot;.svn&quot; EXCLUDE</div>
<div class="line">)</div>
</div><!-- fragment --><h2><a class="anchor" id="python_hyperlink"></a>
Como utilizar una libreria compartida (.so) en python</h2>
<p>Si le interesa saber como utilizar un .so en python puede ver la siguiente pagina agregar_so_python</p>
<h1><a class="anchor" id="steps_sec4"></a>
Paso 4: Publicación de las coordenadas resultantes en un ROS Topic junto con su timestamp</h1>
<p>En este paso del proyecto, se publican las coordenadas resultantes en un ROS Topic junto con su timestamp. Esto permite que otros nodos de ROS puedan suscribirse a este topic y obtener las coordenadas actualizadas del objeto.</p>
<p>El proceso de publicación de las coordenadas se realiza utilizando el framework ROS y su sistema de publicación y suscripción de mensajes. A continuación, se describe el flujo de trabajo para realizar esta tarea:</p>
<ol type="1">
<li>Definir un mensaje: Antes de publicar las coordenadas, se debe definir un mensaje personalizado en ROS que contenga los campos necesarios para almacenar las coordenadas X e Y, así como el timestamp correspondiente. Para ello se escogio un mensaje de tipo PointStamped que ya viene definido en ROS. Este mensaje contiene los campos necesarios para almacenar las coordenadas X e Y, así como el timestamp correspondiente.</li>
<li>Crear un publicador: En el nodo responsable de la detección y cálculo de las coordenadas, se debe crear un objeto publicador que esté configurado para publicar mensajes en el topic específico. El publicador se crea utilizando la biblioteca de ROS y se especifica el tipo de mensaje que se publicará (el mensajes definido en el paso anterior). Esto se puede ver en el archivo <code><a class="el" href="enable__camera_8cpp.html">enable_camera.cpp</a></code>: <div class="fragment"><div class="line">ros::Publisher marker_center_pub = nh.advertise&lt;geometry_msgs::PointStamped&gt;(<span class="stringliteral">&quot;camera/marker_center&quot;</span>, 1);</div>
</div><!-- fragment --></li>
<li>Actualizar y publicar las coordenadas: En cada iteración del bucle de detección y cálculo de coordenadas, se actualizan los valores de las coordenadas y se establece el timestamp actual. A continuación, se empaquetan los valores de las coordenadas y el timestamp en un objeto de mensaje y se publica a través del publicador creado en el paso anterior. Esto se puede ver en el archivo <code><a class="el" href="enable__camera_8cpp.html">enable_camera.cpp</a></code>: <div class="fragment"><div class="line">            <span class="comment">// for each marker, draw info and its boundaries in the image</span></div>
<div class="line">            <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; markers.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                markers[i].draw(frame, cv::Scalar(0, 0, 255), 2);</div>
<div class="line">                <span class="comment">//get center of marker</span></div>
<div class="line">                cv::Point2f center = markers[i].getCenter();</div>
<div class="line">                <span class="comment">//publish center of marker</span></div>
<div class="line">                <span class="keywordtype">int</span> x = center.x;</div>
<div class="line">                <span class="keywordtype">int</span> y = center.y;</div>
<div class="line">                <span class="comment">//call multiply .so function</span></div>
<div class="line">                <a class="code hl_function" href="multiply_8cpp.html#ad8d9ee68852e46ad9115ffae3bb0bc0b">multiply</a>(&amp;x, &amp;y);</div>
<div class="line">                geometry_msgs::PointStamped marker_center;</div>
<div class="line">                marker_center.header.stamp = ros::Time::now();</div>
<div class="line">                marker_center.point.x = x;</div>
<div class="line">                marker_center.point.y = y;</div>
<div class="line">                marker_center_pub.publish(marker_center);</div>
<div class="line">            }</div>
</div><!-- fragment --> Una vez que las coordenadas se publican en el topic, otros nodos de ROS pueden suscribirse a este topic y recibir las coordenadas actualizadas en tiempo real. Esto permite la integración con otros componentes del sistema o la realización de acciones específicas basadas en las coordenadas detectadas. </li>
</ol>
<h1><a class="anchor" id="steps_sec5"></a>
Paso 5: Desarrollo de un Wrapper de gRPC para convertir el ROS Topic en un servicio RPC</h1>
<p>En este paso del proyecto, se desarrolla un Wrapper de gRPC que convierte el ROS Topic de las coordenadas en un servicio RPC. Esto permite la comunicación entre el nodo ROS y otros programas o sistemas que pueden consumir el servicio RPC.</p>
<p>El Wrapper de gRPC se implementa utilizando el lenguaje de programación Python y las bibliotecas de gRPC y ROS. A continuación, se describe el flujo de trabajo para convertir el ROS Topic en un servicio RPC utilizando el Wrapper de gRPC:</p><ol type="1">
<li>Definir el servicio RPC: Antes de implementar el Wrapper de gRPC, se debe definir el servicio RPC que se proporcionará. El servicio debe tener una interfaz clara que especifique los métodos que estarán disponibles y los tipos de datos que se utilizarán. Para esto, se utiliza la herramienta <code>protoc</code> para definir el mensaje enviado por gRPC. El archivo <code>.proto</code> contiene la definición del mensaje y se utiliza para generar los archivos de código necesarios. A continuación se puede observar el archivo <code>.proto</code> usado en este proyecto <code><a class="el" href="proto_2PositionService_8proto.html">pycam/proto/PositionService.proto</a></code>: <pre class="fragment"> syntax = "proto3";
 
 package object_position;
 message Empty {
 }
  // El mensaje de respuesta que contiene la posición
  message Position {
    double x = 1;
    double y = 2;
    int64 timestamp = 3; // Este campo representa el timestamp del mensaje.
  }
 
  // La definición del servicio
  service PositionService {
    // Envía una posición
    rpc SendPosition (Empty) returns (Position);
  }
</pre></li>
<li>Generar los archivos de código: Utilizando el compilador de gRPC y el archivo <code>.proto</code>, se deben generar los archivos de código necesarios para implementar el servicio RPC. Estos archivos incluyen los stubs del cliente y del servidor, así como los mensajes definidos en el servicio. Para generar los archivos se utilizo el siguiente comando: <pre class="fragment">$ python -m grpc_tools.protoc --python_out=. --grpc_python_out=. nombre_del_archivo.proto
</pre> Y obtuvimos los archivos <code><a class="el" href="PositionService__pb2_8py.html">PositionService_pb2.py</a></code> y <code><a class="el" href="PositionService__pb2__grpc_8py.html">PositionService_pb2_grpc.py</a></code> que se pueden ver en la carpeta <code>pycam/src/</code>.</li>
<li>Configurar y ejecutar el wrapper gRPC: Se crea un wrapper cuya función es configurar el servidor gRPC para que escuche en un puerto específico y acepte conexiones entrantes. Y ademas el wrapper va acruat om un nodo de ros el cual se va a subscribir al topico de posición para siempre tener el valor mas actualizado. De esta manera cuando un cliente quiere obtener la posición del objeto, el wrapper le va a devolver la posición que tiene guardada en el momento. Se puede observar el codigo implementado en el archivo <code><a class="el" href="grpc__wrapper_8py.html">grpc_wrapper.py</a></code>: <div class="fragment"><div class="line"><span class="comment">#!/usr/bin/env python3</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">@file grpc_wrapper.py</span></div>
<div class="line"><span class="stringliteral">@author Ian De La Garza</span></div>
<div class="line"><span class="stringliteral">@date 28 de mayo de 2023</span></div>
<div class="line"><span class="stringliteral">@brief Este archivo contiene la clase PositionServiceServicer que </span></div>
<div class="line"><span class="stringliteral">sirve como servidor para enviar datos de posición a través de gRPC.</span></div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> time</div>
<div class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> grpc</div>
<div class="line"><span class="keyword">import</span> rospy</div>
<div class="line"><span class="keyword">from</span> geometry_msgs.msg <span class="keyword">import</span> PointStamped</div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> PositionService_pb2</div>
<div class="line"><span class="keyword">import</span> PositionService_pb2_grpc</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>PositionServiceServicer(<a class="code hl_class" href="classPositionService__pb2__grpc_1_1PositionServiceServicer.html">PositionService_pb2_grpc.PositionServiceServicer</a>):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    </span><span class="preprocessor">@brief</span> Servidor gRPC que transmite datos de posición.</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    </span><span class="keyword">def </span>__init__(self):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        </span><span class="preprocessor">@brief</span> Inicializa el nodo ROS, se suscribe a <span class="stringliteral">&quot;/camera/marker_center&quot;</span> </div>
<div class="line">        y configura el servidor gRPC.</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        </span></div>
<div class="line"><span class="stringliteral">        self.latest_message = PointStamped()</span></div>
<div class="line"><span class="stringliteral">        rospy.init_node(&#39;position_listener&#39;</span>, anonymous=<span class="keyword">True</span>)</div>
<div class="line"> </div>
<div class="line">        </div>
<div class="line">        rospy.Subscriber(<span class="stringliteral">&quot;/camera/marker_center&quot;</span>, PointStamped, self.callback)</div>
<div class="line">        </div>
<div class="line">        self.server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>callback(self, data):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        </span><span class="preprocessor">@brief</span> Callback para el suscriptor ROS, actualiza el mensaje más reciente.</div>
<div class="line"> </div>
<div class="line">        <span class="preprocessor">@param</span> data El nuevo mensaje de posición a guardar.</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">        self.latest_message = data</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    </span><span class="keyword">def </span>SendPosition(self, empty, context):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        </span><span class="preprocessor">@brief</span> Envía los datos de posición actuales a través de gRPC.</div>
<div class="line"> </div>
<div class="line">        <span class="preprocessor">@param</span> empty El objeto vacío enviado por el cliente, no se utiliza.</div>
<div class="line">        <span class="preprocessor">@param</span> context El contexto gRPC, no se utiliza.</div>
<div class="line"> </div>
<div class="line">        <span class="preprocessor">@return</span> Una respuesta de posición que contiene los datos de posición más recientes.</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        </span><span class="keywordflow">if</span> self.latest_message <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line">            response = PositionService_pb2.Position()</div>
<div class="line">            response.x = self.latest_message.point.x</div>
<div class="line">            response.y = self.latest_message.point.y</div>
<div class="line">            response.timestamp = self.latest_message.header.stamp.nsecs</div>
<div class="line">            <span class="keywordflow">return</span> response</div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            <span class="keywordflow">raise</span> grpc.RpcError(<span class="stringliteral">&quot;No position data received yet&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>serve(self):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        </span><span class="preprocessor">@brief</span> Inicia el servidor gRPC.</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        <a class="code hl_function" href="namespacePositionService__pb2__grpc.html#ad7a61e046f4995370d5de21ed6992798">PositionService_pb2_grpc.add_PositionServiceServicer_to_server</a>(self, self.server)</span></div>
<div class="line"><span class="stringliteral">        self.server.add_insecure_port(&#39;[::]:50051&#39;</span>)</div>
<div class="line">        self.server.start()</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>serverStop(self):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        </span><span class="preprocessor">@brief</span> Detiene el servidor gRPC.</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        self.server.stop(0)</span></div>
<div class="line"><span class="stringliteral">    </span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral"></span><span class="keywordflow">if</span> __name__ == <span class="stringliteral">&#39;__main__&#39;</span>:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    </span><span class="preprocessor">@brief</span> El punto de entrada del programa. </div>
<div class="line">    Se crea una instancia de PositionServiceServicer y se inicia el servidor gRPC.</div>
<div class="line">    Cuando se interrumpe el programa (p.ej., se presiona Ctrl+C), se detiene el servidor gRPC.</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    </span></div>
<div class="line"><span class="stringliteral">    servicer = PositionServiceServicer()</span></div>
<div class="line"><span class="stringliteral">    servicer.serve()</span></div>
<div class="line"><span class="stringliteral">    </span><span class="keywordflow">try</span>:</div>
<div class="line">        rospy.spin()</div>
<div class="line">    <span class="keywordflow">except</span> KeyboardInterrupt:</div>
<div class="line">        servicer.serverStop()</div>
<div class="ttc" id="aclassPositionService__pb2__grpc_1_1PositionServiceServicer_html"><div class="ttname"><a href="classPositionService__pb2__grpc_1_1PositionServiceServicer.html">PositionService_pb2_grpc.PositionServiceServicer</a></div><div class="ttdef"><b>Definition</b> PositionService_pb2_grpc.py:25</div></div>
<div class="ttc" id="anamespacePositionService__pb2__grpc_html_ad7a61e046f4995370d5de21ed6992798"><div class="ttname"><a href="namespacePositionService__pb2__grpc.html#ad7a61e046f4995370d5de21ed6992798">PositionService_pb2_grpc.add_PositionServiceServicer_to_server</a></div><div class="ttdeci">add_PositionServiceServicer_to_server(servicer, server)</div><div class="ttdef"><b>Definition</b> PositionService_pb2_grpc.py:37</div></div>
</div><!-- fragment --></li>
</ol>
<p>Una vez que se ha implementado el Wrapper de gRPC y configurado el servidor, otros programas o sistemas pueden consumir el servicio RPC para obtener las coordenadas del objeto. Esto permite la integración con diferentes plataformas y la comunicación eficiente de las coordenadas.</p>
<h1><a class="anchor" id="steps_sec56"></a>
Paso 6: Implementación de un programa en Java que consume el servicio RPC y muestra las coordenadas en la terminal</h1>
<p>En este paso del proyecto, se implementa un programa en Java que consume el servicio RPC generado en el paso anterior y muestra las coordenadas del objeto en la terminal.</p>
<p>A continuación, se describe el flujo de trabajo para implementar el programa en Java que consume el servicio RPC:</p>
<ol type="1">
<li>Configurar el entorno de desarrollo: Antes de comenzar, nos aseguramos de tener instalado el entorno de desarrollo de Java, como JDK (Java Development Kit) y un IDE (Integrated Development Environment) en nuestro caso usamos Visual Studio Code.</li>
<li>Importar el código generado: Importamos los archivos de código generados por el compilador de gRPC en el proyecto Java. Estos archivos incluyen los stubs del cliente y los mensajes definidos en el servicio RPC. Utilizamos Maven para manejar las dependencias y compilar el archivo .proto en el proyecto de Java.</li>
<li>Configurar la conexión al servicio RPC: En el programa Java, configuramos la conexión al servicio RPC proporcionando la dirección y el puerto del servidor gRPC. Se utilizo los stubs del cliente generados para establecer la conexión y crear un cliente gRPC.</li>
<li>Llamar al método del servicio RPC: Utilizando el cliente gRPC, llamamos el método del servicio RPC que devuelve las coordenadas del objeto. Pasa los parámetros necesarios según la definición del servicio y captura la respuesta del servidor.</li>
<li>Procesar la respuesta y mostrar las coordenadas: Procesamos la respuesta recibida del servidor gRPC y muestra las coordenadas del objeto en la terminal, en el formato deseado.</li>
</ol>
<p>El codigo se puede observar en el archivo <code><a class="el" href="App_8java.html" title="Este archivo contiene la clase App, que implementa un cliente gRPC para el servicio PositionService.">App.java</a></code>: </p><div class="fragment"><div class="line"><span class="keyword">package </span>com.example;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> com.google.protobuf.Empty;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> io.grpc.ManagedChannel;</div>
<div class="line"><span class="keyword">import</span> io.grpc.ManagedChannelBuilder;</div>
<div class="line"><span class="keyword">import</span> <a class="code hl_package" href="namespaceobject__position.html">object_position</a>.<a class="code hl_class" href="classobject__position_1_1PositionServiceGrpc.html">PositionServiceGrpc</a>;</div>
<div class="line"><span class="keyword">import</span> <a class="code hl_package" href="namespaceobject__position.html">object_position</a>.<a class="code hl_class" href="classobject__position_1_1PositionServiceOuterClass.html">PositionServiceOuterClass</a>.<a class="code hl_class" href="classobject__position_1_1PositionServiceOuterClass_1_1Position.html">Position</a>;</div>
<div class="line"><span class="keyword">public</span> <span class="keyword">class </span>App </div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code hl_function" href="classcom_1_1example_1_1App.html#a28228b12da000bb30a163d24a7c43c35">main</a>(String[] args) <span class="keywordflow">throws</span> Exception {</div>
<div class="line">        ManagedChannel channel = ManagedChannelBuilder.forTarget(<span class="stringliteral">&quot;192.168.55.1:50051&quot;</span>)</div>
<div class="line">        .usePlaintext()</div>
<div class="line">        .build();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Reemplace &#39;MyServiceGrpc&#39; y &#39;MyRequest&#39; con los nombres de tu servicio y tu mensaje.</span></div>
<div class="line">        PositionServiceGrpc.PositionServiceBlockingStub stub = PositionServiceGrpc.newBlockingStub(channel);</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="keywordflow">while</span>(<span class="keyword">true</span>) {</div>
<div class="line">                Position response = stub.sendPosition(<span class="keyword">null</span>);</div>
<div class="line">                System.out.println(<span class="stringliteral">&quot;Response x: &quot;</span> + response.getX() + <span class="stringliteral">&quot;Response y: &quot;</span> + response.getY() + <span class="stringliteral">&quot; Timestamp: &quot;</span> + response.getTimestamp());</div>
<div class="line">                Thread.sleep(10);  <span class="comment">// Add delay of 1 second between each request</span></div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">catch</span> (InterruptedException e) {</div>
<div class="line">            System.out.println(<span class="stringliteral">&quot;Shutting down due to user request.&quot;</span>);</div>
<div class="line">        } <span class="keywordflow">finally</span> {</div>
<div class="line">            channel.shutdown();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="ttc" id="aclasscom_1_1example_1_1App_html_a28228b12da000bb30a163d24a7c43c35"><div class="ttname"><a href="classcom_1_1example_1_1App.html#a28228b12da000bb30a163d24a7c43c35">com.example.App.main</a></div><div class="ttdeci">static void main(String[] args)</div><div class="ttdoc">Punto de entrada del programa. Se establece una conexión gRPC con el servidor y se realizan solicitud...</div><div class="ttdef"><b>Definition</b> App.java:24</div></div>
<div class="ttc" id="aclassobject__position_1_1PositionServiceGrpc_html"><div class="ttname"><a href="classobject__position_1_1PositionServiceGrpc.html">object_position.PositionServiceGrpc</a></div><div class="ttdef"><b>Definition</b> PositionServiceGrpc.java:14</div></div>
<div class="ttc" id="aclassobject__position_1_1PositionServiceOuterClass_1_1Position_html"><div class="ttname"><a href="classobject__position_1_1PositionServiceOuterClass_1_1Position.html">object_position.PositionServiceOuterClass.Position</a></div><div class="ttdef"><b>Definition</b> PositionServiceOuterClass.java:471</div></div>
<div class="ttc" id="aclassobject__position_1_1PositionServiceOuterClass_html"><div class="ttname"><a href="classobject__position_1_1PositionServiceOuterClass.html">object_position.PositionServiceOuterClass</a></div><div class="ttdef"><b>Definition</b> PositionServiceOuterClass.java:6</div></div>
<div class="ttc" id="anamespaceobject__position_html"><div class="ttname"><a href="namespaceobject__position.html">object_position</a></div><div class="ttdef"><b>Definition</b> PositionServiceGrpc.java:1</div></div>
</div><!-- fragment --><h1><a class="anchor" id="steps_sec7"></a>
Paso 7: Uso de grpc-Gateway para exponer el servicio como un REST-API</h1>
<p>En este paso del proyecto, se utiliza grpc-Gateway para exponer el servicio RPC generado anteriormente como un REST-API. Esto permite a otros sistemas o aplicaciones consumir el servicio RPC utilizando protocolos RESTful estándar.</p>
<p>A continuación, se describe el flujo de trabajo para utilizar grpc-Gateway y exponer el servicio RPC como un REST-API:</p>
<ol type="1">
<li>Configurar grpc-Gateway: Antes de comenzar, instalamos el entorno de desarrollo, se utilizo el github oficial de grpc-Gateway para obtener instrucciones sobre cómo instalarlo.</li>
<li>Definir el archivo de configuración: Generamos una copia del archivo proto y creamos otro arhivo configuración proto pero le agregamos las especificaciones de la configuración del gateway. En este archivo se definio cómo se mapean los endpoints REST a los métodos del servicio RPC. A continuación se puede observar el archivo <code>.proto</code> usado en este proyecto <code><a class="el" href="PositionServiceGo_8proto.html">go/positionGateway/PositionServiceGo.proto</a></code>: <pre class="fragment">syntax = "proto3";

package object_position;
option go_package = ".";
import "google/api/annotations.proto";

message Empty {
}
// The response message containing the greetings
message Position {
  double x = 1;
  double y = 2;
  int64 timestamp = 3; // timestamp as UNIX epoch time
}

// The service definition.
service PositionService {
  // Sends a greeting
  rpc SendPosition (Empty) returns (Position){
    option (google.api.http) = {
      get: "/position"
    };
  }
}
</pre></li>
<li>Generar el servidor proxy: Utilizando el compilador de grpc-Gateway, generamoos el código del servidor proxy que actuará como intermediario entre las solicitudes REST y el servicio RPC. El servidor proxy se encargará de traducir las solicitudes REST a llamadas RPC y viceversa.</li>
<li>Implementar el servidor proxy: Implementamos el servidor proxy en el lenguaje de Go. El servidor proxy debe configurarse para escuchar en un puerto específico y gestionar las solicitudes REST entrantes.</li>
</ol>
<p>La implementación del servidor proxy se puede observar en el archivo <code>go/main.go</code>: </p><div class="fragment"><div class="line">package main</div>
<div class="line"> </div>
<div class="line">import (</div>
<div class="line">    &quot;context&quot;</div>
<div class="line">    &quot;log&quot;</div>
<div class="line">    &quot;net/http&quot;</div>
<div class="line"> </div>
<div class="line">    &quot;google.golang.org/grpc&quot;</div>
<div class="line">    &quot;github.com/grpc-ecosystem/grpc-gateway/v2/runtime&quot;</div>
<div class="line"> </div>
<div class="line">    pb &quot;positionGate/positionGateway&quot;</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">func main() {</div>
<div class="line">    ctx := context.Background()</div>
<div class="line">    mux := runtime.NewServeMux()</div>
<div class="line"> </div>
<div class="line">    // Create a gRPC connection to your existing Python gRPC server</div>
<div class="line">    grpcServerEndpoint := &quot;localhost:50051&quot; // Replace with the actual address of your Python gRPC server</div>
<div class="line">    opts := []grpc.DialOption{grpc.WithInsecure()}</div>
<div class="line">    err := pb.RegisterPositionServiceHandlerFromEndpoint(ctx, mux, grpcServerEndpoint, opts)</div>
<div class="line">    if err != nil {</div>
<div class="line">        log.Fatalf(&quot;failed to register gateway: %v&quot;, err)</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // Start the HTTP server</div>
<div class="line">    httpAddr := &quot;:8080&quot; // Set the listening address for the gateway server</div>
<div class="line">    log.Printf(&quot;gRPC gateway server listening on %s&quot;, httpAddr)</div>
<div class="line">    if err := http.ListenAndServe(httpAddr, mux); err != nil {</div>
<div class="line">        log.Fatalf(&quot;failed to serve: %v&quot;, err)</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>Ejecutar el servidor proxy: Inicia el servidor proxy y asegúrate de que esté en funcionamiento y escuchando en el puerto especificado. Puedes probar el servidor proxy enviando solicitudes REST utilizando herramientas como cURL o Postman y verificar las respuestas recibidas.</li>
</ol>
<p>Si quiere ver el servidor proxy funcionando puedes ver el video de la demostración del proyecto que esta al inicio.</p>
<h1><a class="anchor" id="steps_sec8"></a>
Paso 8:  Adquisición de las coordenadas del objeto desde el nuevo REST-API utilizando Postman o Flask, y guardar los datos en un archivo JSON</h1>
<p>A continuación, se describe el flujo de trabajo para adquirir las coordenadas del objeto utilizando Postman o Flask:</p>
<ol type="1">
<li>Configurar el entorno: Insalamos Postman. Postman es una herramienta de desarrollo de API que permite enviar solicitudes HTTP y recibir respuestas.</li>
<li>Crear una solicitud HTTP: Utilizando Postman, creamos una solicitud HTTP a la ruta específica del REST-API que proporciona las coordenadas del objeto.</li>
<li>Enviar la solicitud: Envíamos la solicitud HTTP al REST-API y esperamos la respuesta. Se puede ver la respuesta directamente en la interfaz de Postman.</li>
<li>Guardar los datos en un archivo JSON: Una vez recibido la respuesta del REST-API, extramos los datos de coordenadas del objeto y guardarlos en un archivo JSON. </li>
</ol>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
