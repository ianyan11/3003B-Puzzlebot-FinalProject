\chapter{Proyecto de Captura y Procesamiento de Coordenadas de Objeto utilizando ROS, g\+RPC y REST-\/\+API}
\hypertarget{index}{}\label{index}\index{Proyecto de Captura y Procesamiento de Coordenadas de Objeto utilizando ROS, gRPC y REST-\/API@{Proyecto de Captura y Procesamiento de Coordenadas de Objeto utilizando ROS, gRPC y REST-\/API}}
\hypertarget{index_intro_sec}{}\doxysection{\texorpdfstring{Introducción}{Introducción}}\label{index_intro_sec}
Este proyecto tiene como objetivo principal capturar una imagen de la webcam, detectar un objeto verde en la imagen y calcular sus coordenadas X e Y. Utiliza el Robot Operating System (ROS), Python, C++, g\+RPC y REST-\/\+API para lograr esta funcionalidad.

Se puede un video del proyecto funcionando en \href{https://drive.google.com/file/d/1gfKTAAFY7mNjZSFFG5LzwTAjmISHOkOd/view?usp=sharing}{\texttt{ https\+://drive.\+google.\+com/file/d/1gf\+KTAAFY7m\+Nj\+ZSFFG5\+Lzw\+TAjm\+ISHOk\+Od/view?usp=sharing}}\hypertarget{index_steps_sec}{}\doxysection{\texorpdfstring{Pasos del Proyecto}{Pasos del Proyecto}}\label{index_steps_sec}

\begin{DoxyEnumerate}
\item Captura de imagen y detección del objeto verde utilizando un ROS Node en Python.
\item Creación de una librería en C++ para multiplicar las coordenadas por 100.
\item Integración de la librería C++ en el ROS Node para realizar la operación de multiplicación.
\item Publicación de las coordenadas resultantes en un ROS Topic junto con su timestamp.
\item Desarrollo de un Wrapper de g\+RPC para convertir el ROS Topic en un servicio RPC.
\item Implementación de un programa en C\# que consume el servicio RPC y muestra las coordenadas en la terminal.
\item Uso de grpc-\/\+Gateway para exponer el servicio como un REST-\/\+API.
\item Adquisición de las coordenadas del objeto desde el nuevo REST-\/\+API utilizando Postman o Flask, y guardar los datos en un archivo JSON.
\end{DoxyEnumerate}\hypertarget{index_lang_sec}{}\doxysection{\texorpdfstring{Lenguajes y Plataformas}{Lenguajes y Plataformas}}\label{index_lang_sec}
El proyecto utiliza los siguientes lenguajes y plataformas\+:


\begin{DoxyItemize}
\item Python\+: como wrapper para mandar el topico de ros por medio de un serivicio RPC.
\item C++\+: para la captura de imagen y detección de objeto utilizando el ROS Node. Tambien la creación de la librería que realiza la multiplicación de las coordenadas.
\item ROS\+: como plataforma de desarrollo y comunicación entre los componentes.
\item g\+RPC\+: para la comunicación entre el ROS Node y el programa en Java a través de un servicio RPC.
\item Java\+: para el programa que consume el servicio RPC y muestra las coordenadas en la terminal.
\item grpc-\/\+Gateway junto con Go\+: para exponer el servicio como un REST-\/\+API.
\item Postman o Flask\+: para adquirir las coordenadas desde el REST-\/\+API y guardar los datos en un archivo JSON.
\item Protoc\+: para definir los mensajes y servicios utilizados en la comunicación g\+RPC.
\end{DoxyItemize}\hypertarget{index_comp_sec}{}\doxysection{\texorpdfstring{Componentes Principales}{Componentes Principales}}\label{index_comp_sec}
Los componentes principales del proyecto son\+:


\begin{DoxyItemize}
\item ROS Node en C++\+: captura una imagen de la webcam, detecta el objeto verde y calcula las coordenadas X e Y.
\item Librería en C++\+: realiza la multiplicación de las coordenadas por 100.
\item Wrapper de g\+RPC\+: convierte el ROS Topic en un servicio RPC.
\item Protoc\+: define los mensajes y servicios utilizados en la comunicación g\+RPC.
\item Programa en C\#\+: muestra las coordenadas del objeto en la terminal al consumir el servicio RPC.
\item grpc-\/\+Gateway\+: expone el servicio como un REST-\/\+API para obtener las coordenadas.
\item Postman o Flask\+: adquiere las coordenadas desde el REST-\/\+API y las guarda en un archivo JSON.
\end{DoxyItemize}\hypertarget{index_steps_sec1}{}\doxysection{\texorpdfstring{Paso 1\+: Captura de imagen y detección del objeto verde utilizando un ROS Node en C++}{Paso 1: Captura de imagen y detección del objeto verde utilizando un ROS Node en C++}}\label{index_steps_sec1}
\hypertarget{index_code_sec}{}\doxysubsection{\texorpdfstring{Código Fuente}{Código Fuente}}\label{index_code_sec}
El código fuente para este paso se encuentra en el archivo {\ttfamily \doxylink{enable__camera_8cpp}{enable\+\_\+camera.\+cpp}}.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}ros/ros.h"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}ros/console.h"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <geometry\_msgs/PointStamped.h>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <image\_transport/image\_transport.h>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <opencv2/opencv.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <cv\_bridge/cv\_bridge.h>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <aruco\_ros/aruco\_ros\_utils.h>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}\mbox{\hyperlink{multiply_8h}{pycam/multiply.h}}"{}}}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \mbox{\hyperlink{enable__camera_8cpp_a3c04138a5bfe5d72780bb7e82a18e627}{main}}(\textcolor{keywordtype}{int}\ argc,\ \textcolor{keywordtype}{char}**\ argv)\ \{}
\DoxyCodeLine{\ \ \ \ ros::init(argc,\ argv,\ \textcolor{stringliteral}{"{}webcam\_publish\_test"{}});}
\DoxyCodeLine{\ \ \ \ ros::NodeHandle\ nh;}
\DoxyCodeLine{\ \ \ \ image\_transport::ImageTransport\ it(nh);}
\DoxyCodeLine{\ \ \ \ image\_transport::Publisher\ pub\ =\ it.advertise(\textcolor{stringliteral}{"{}camera/image"{}},\ 1);}
\DoxyCodeLine{\ \ \ \ image\_transport::Publisher\ marker\_pub\ =\ it.advertise(\textcolor{stringliteral}{"{}camera/marker\_image"{}},\ 1);}
\DoxyCodeLine{\ \ \ \ ros::Publisher\ marker\_center\_pub\ =\ nh.advertise<geometry\_msgs::PointStamped>(\textcolor{stringliteral}{"{}camera/marker\_center"{}},\ 1);}
\DoxyCodeLine{\ \ \ \ ros::Rate\ rate(30);}
\DoxyCodeLine{\ \ \ \ cv::VideoCapture\ cap(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}nvarguscamerasrc\ !\ video/x-\/raw(memory:NVMM),\ width=(int)720,\ height=(int)480,format=(string)NV12,\ framerate=(fraction)30/1\ !\ nvvidconv\ !\ video/x-\/raw,\ format=(string)BGRx\ !\ videoconvert\ !\ \ appsink"{}},\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ cv::CAP\_GSTREAMER);}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{if}\ (!cap.isOpened())\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ROS\_ERROR(\textcolor{stringliteral}{"{}Could\ not\ open\ camera"{}});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ -\/1;}
\DoxyCodeLine{\ \ \ \ \}\ }
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ stuff\ =\ cap.set(cv::CAP\_PROP\_FPS,\ 30);}
\DoxyCodeLine{\ \ \ \ aruco::CameraParameters\ camParam\ =\ aruco::CameraParameters();}
\DoxyCodeLine{\ \ \ \ cv::Mat\ frame,\ frame2;}
\DoxyCodeLine{\ \ \ \ aruco::MarkerDetector\ mDetector;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{float}\ min\_marker\_size;\ \textcolor{comment}{//\ percentage\ of\ image\ area}}
\DoxyCodeLine{\ \ \ \ nh.param<\textcolor{keywordtype}{float}>(\textcolor{stringliteral}{"{}min\_marker\_size"{}},\ min\_marker\_size,\ 0.01);}
\DoxyCodeLine{\ \ \ \ std::vector<aruco::Marker>\ markers;}
\DoxyCodeLine{\ \ \ \ mDetector.setDetectionMode(aruco::DM\_VIDEO\_FAST,\ min\_marker\_size);}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{while}\ (ros::ok())\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ markers.clear();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ cap\ >>\ frame;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (frame.rows)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ resize\ image\ to\ 640x480}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ cv::resize(frame,\ frame,\ cv::Size(640,\ 480));}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//make\ frame\ sharper}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ cv::GaussianBlur(frame,\ frame2,\ cv::Size(0,\ 0),\ 3);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ cv::addWeighted(frame,\ 1.5,\ frame2,\ -\/0.6,\ 0,\ frame);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ cv::resize(frame,\ frame2,\ cv::Size(320,\ 240));}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ detect\ markers}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ sensor\_msgs::ImagePtr\ msg\ =\ cv\_bridge::CvImage(std\_msgs::Header(),\ \textcolor{stringliteral}{"{}bgr8"{}},\ frame2).toImageMsg();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ pub.publish(msg);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ mDetector.detect(frame,\ markers,\ camParam);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ for\ each\ marker,\ draw\ info\ and\ its\ boundaries\ in\ the\ image}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (std::size\_t\ i\ =\ 0;\ i\ <\ markers.size();\ ++i)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ markers[i].draw(frame,\ cv::Scalar(0,\ 0,\ 255),\ 2);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//get\ center\ of\ marker}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ cv::Point2f\ center\ =\ markers[i].getCenter();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//publish\ center\ of\ marker}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ x\ =\ center.x;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ y\ =\ center.y;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//call\ multiply\ .so\ function}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{multiply_8cpp_ad8d9ee68852e46ad9115ffae3bb0bc0b}{multiply}}(\&x,\ \&y);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ geometry\_msgs::PointStamped\ marker\_center;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ marker\_center.header.stamp\ =\ ros::Time::now();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ marker\_center.point.x\ =\ x;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ marker\_center.point.y\ =\ y;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ marker\_center\_pub.publish(marker\_center);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}(markers.size()\ >\ 0)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ cv::resize(frame,\ frame2,\ cv::Size(320,\ 240));}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ marker\_pub.publish(cv\_bridge::CvImage(std\_msgs::Header(),\ \textcolor{stringliteral}{"{}bgr8"{}},\ frame2).toImageMsg());}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ rate.sleep();}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ cap.release();}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{\}}

\end{DoxyCodeInclude}
\hypertarget{index_description_sec}{}\doxysubsection{\texorpdfstring{Descripción del Código}{Descripción del Código}}\label{index_description_sec}
En esta etapa, inicializamos un nodo ROS llamado \"{}webcam\+\_\+publish\+\_\+test\"{} y configuramos varios publicadores y suscriptores. El código entonces comienza a capturar imágenes desde la webcam utilizando Open\+CV y detecta marcadores Ar\+Uco en la imagen.

Cada vez que se captura una imagen, se publica en el tópico \"{}camera/image\"{}. Si se detectan marcadores Ar\+Uco en la imagen, se dibujan en la imagen y se publica en el tópico \"{}camera/marker\+\_\+image\"{}. El centro del marcador detectado se calcula, se multiplica por 100 y se publica en el tópico \"{}camera/marker\+\_\+center\"{}.

La detección de marcadores Ar\+Uco se realiza utilizando la biblioteca Ar\+Uco. Los marcadores son objetos cuadrados en el mundo real que pueden ser fácilmente detectados y identificados en imágenes. Son útiles para la calibración de cámaras y la estimación de la pose en aplicaciones de realidad aumentada. El código detecta los marcadores utilizando el modo de detección rápido de video ({\ttfamily DM\+\_\+\+VIDEO\+\_\+\+FAST}) con un tamaño mínimo de marcador especificado por el parámetro \"{}min\+\_\+marker\+\_\+size\"{}.

El código continúa en un bucle hasta que se detiene el nodo ROS. Luego, libera la cámara y finaliza.\hypertarget{index_usage_sec1}{}\doxysubsection{\texorpdfstring{Uso del Código}{Uso del Código}}\label{index_usage_sec1}
Para usar este código, debses tener una webcam compatible y un marcador Ar\+Uco visible en la imagen de la webcam. Puedes ajustar el tamaño mínimo del marcador y la frecuencia de captura de imágenes cambiando los parámetros \"{}min\+\_\+marker\+\_\+size\"{} y \"{}rate\"{}, respectivamente.\hypertarget{index_steps_sec2}{}\doxysection{\texorpdfstring{Paso 2\+: Creación de una librería en C++ para multiplicar las coordenadas por 100}{Paso 2: Creación de una librería en C++ para multiplicar las coordenadas por 100}}\label{index_steps_sec2}
\hypertarget{index_code_sec}{}\doxysubsection{\texorpdfstring{Código Fuente}{Código Fuente}}\label{index_code_sec}
El código fuente para este paso se encuentra en los archivos {\ttfamily \doxylink{multiply_8h}{multiply.\+h}} y {\ttfamily \doxylink{multiply_8cpp}{multiply.\+cpp}}.

{\ttfamily \doxylink{multiply_8cpp}{multiply.\+cpp}} 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{extern}\ \textcolor{stringliteral}{"{}C"{}}\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{multiply_8cpp_ad8d9ee68852e46ad9115ffae3bb0bc0b}{multiply}}(\textcolor{keywordtype}{int}*\ x,\ \textcolor{keywordtype}{int}*\ y)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ *x\ *=\ 100;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ *y\ *=\ 100;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCodeInclude}
 {\ttfamily \doxylink{multiply_8h}{multiply.\+h}} 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#ifdef\ \_\_cplusplus}}
\DoxyCodeLine{\textcolor{keyword}{extern}\ \textcolor{stringliteral}{"{}C"{}}\ \{}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{multiply_8cpp_ad8d9ee68852e46ad9115ffae3bb0bc0b}{multiply}}(\textcolor{keywordtype}{int}*\ a,\ \textcolor{keywordtype}{int}*\ b);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#ifdef\ \_\_cplusplus}}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}

\end{DoxyCodeInclude}
\hypertarget{index_description_sec}{}\doxysubsection{\texorpdfstring{Descripción del Código}{Descripción del Código}}\label{index_description_sec}
En esta etapa, creamos una librería en C++ que proporciona una función para multiplicar las coordenadas por 100.

El archivo {\ttfamily \doxylink{multiply_8h}{multiply.\+h}} contiene la declaración de la función {\ttfamily multiply} que toma dos punteros a enteros y multiplica sus valores por 100.

El archivo {\ttfamily \doxylink{multiply_8cpp}{multiply.\+cpp}} contiene la implementación de la función {\ttfamily multiply}. En esta implementación, los valores apuntados por los punteros se multiplican por 100.\hypertarget{index_steps_sec3}{}\doxysection{\texorpdfstring{Paso 3\+: Integración de la librería C++ en el ROS Node para realizar la operación de multiplicación.}{Paso 3: Integración de la librería C++ en el ROS Node para realizar la operación de multiplicación.}}\label{index_steps_sec3}
\hypertarget{index_usage_sec2}{}\doxysubsection{\texorpdfstring{Uso del Código}{Uso del Código}}\label{index_usage_sec2}
Para utilizar esta librería en tu proyecto, debes incluir el archivo de encabezado {\ttfamily \doxylink{multiply_8h}{multiply.\+h}} en tus archivos fuente donde necesites utilizar la función {\ttfamily multiply}. Luego, enlaza tu proyecto con el archivo objeto generado a partir del archivo fuente {\ttfamily \doxylink{multiply_8cpp}{multiply.\+cpp}}.

Puedes llamar a la función {\ttfamily multiply} pasando los valores que deseas multiplicar por 100 como argumentos. Los valores se multiplicarán directamente en su ubicación de memoria. Por lo tanto, no es necesario devolver un valor de la función. Por ejemplo en \doxylink{enable__camera_8cpp}{enable\+\_\+camera.\+cpp} su puede ver como se utiliza la librería\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ x\ =\ center.x;}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ y\ =\ center.y;}
\DoxyCodeLine{\textcolor{comment}{//call\ multiply\ .so\ function}}
\DoxyCodeLine{\mbox{\hyperlink{multiply_8cpp_ad8d9ee68852e46ad9115ffae3bb0bc0b}{multiply}}(\&x,\ \&y);}

\end{DoxyCode}
 Para lograr que el codigo usara el .so al compilar se tuvo que agregar lo siguiente en el {\ttfamily CMakelists.\+txt}\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{include\_directories(}
\DoxyCodeLine{\ \ \ \ \$\{CMAKE\_CURRENT\_SOURCE\_DIR\}/include}
\DoxyCodeLine{)}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{target\_link\_libraries(enable\_camera\ \$\{OpenCV\_LIBRARIES\}\ \$\{catkin\_LIBRARIES\}\ \$\{CMAKE\_CURRENT\_SOURCE\_DIR\}/lib/libmultiply.so)}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{install(DIRECTORY\ include/\$\{PROJECT\_NAME\}/}
\DoxyCodeLine{\ \ DESTINATION\ \$\{CATKIN\_PACKAGE\_INCLUDE\_DESTINATION\}}
\DoxyCodeLine{\ \ FILES\_MATCHING\ PATTERN\ "{}*.h"{}}
\DoxyCodeLine{\ \ PATTERN\ "{}.svn"{}\ EXCLUDE}
\DoxyCodeLine{)}

\end{DoxyCode}
\hypertarget{index_python_hyperlink}{}\doxysubsection{\texorpdfstring{Como utilizar una libreria compartida (.\+so) en python}{Como utilizar una libreria compartida (.so) en python}}\label{index_python_hyperlink}
Si le interesa saber como utilizar un .so en python puede ver la siguiente pagina agregar\+\_\+so\+\_\+python\hypertarget{index_steps_sec4}{}\doxysection{\texorpdfstring{Paso 4\+: Publicación de las coordenadas resultantes en un ROS Topic junto con su timestamp}{Paso 4: Publicación de las coordenadas resultantes en un ROS Topic junto con su timestamp}}\label{index_steps_sec4}
En este paso del proyecto, se publican las coordenadas resultantes en un ROS Topic junto con su timestamp. Esto permite que otros nodos de ROS puedan suscribirse a este topic y obtener las coordenadas actualizadas del objeto.

El proceso de publicación de las coordenadas se realiza utilizando el framework ROS y su sistema de publicación y suscripción de mensajes. A continuación, se describe el flujo de trabajo para realizar esta tarea\+:


\begin{DoxyEnumerate}
\item Definir un mensaje\+: Antes de publicar las coordenadas, se debe definir un mensaje personalizado en ROS que contenga los campos necesarios para almacenar las coordenadas X e Y, así como el timestamp correspondiente. Para ello se escogio un mensaje de tipo Point\+Stamped que ya viene definido en ROS. Este mensaje contiene los campos necesarios para almacenar las coordenadas X e Y, así como el timestamp correspondiente.
\item Crear un publicador\+: En el nodo responsable de la detección y cálculo de las coordenadas, se debe crear un objeto publicador que esté configurado para publicar mensajes en el topic específico. El publicador se crea utilizando la biblioteca de ROS y se especifica el tipo de mensaje que se publicará (el mensajes definido en el paso anterior). Esto se puede ver en el archivo {\ttfamily \doxylink{enable__camera_8cpp}{enable\+\_\+camera.\+cpp}}\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ros::Publisher\ marker\_center\_pub\ =\ nh.advertise<geometry\_msgs::PointStamped>(\textcolor{stringliteral}{"{}camera/marker\_center"{}},\ 1);}

\end{DoxyCode}

\item Actualizar y publicar las coordenadas\+: En cada iteración del bucle de detección y cálculo de coordenadas, se actualizan los valores de las coordenadas y se establece el timestamp actual. A continuación, se empaquetan los valores de las coordenadas y el timestamp en un objeto de mensaje y se publica a través del publicador creado en el paso anterior. Esto se puede ver en el archivo {\ttfamily \doxylink{enable__camera_8cpp}{enable\+\_\+camera.\+cpp}}\+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ for\ each\ marker,\ draw\ info\ and\ its\ boundaries\ in\ the\ image}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (std::size\_t\ i\ =\ 0;\ i\ <\ markers.size();\ ++i)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ markers[i].draw(frame,\ cv::Scalar(0,\ 0,\ 255),\ 2);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//get\ center\ of\ marker}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ cv::Point2f\ center\ =\ markers[i].getCenter();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//publish\ center\ of\ marker}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ x\ =\ center.x;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ y\ =\ center.y;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//call\ multiply\ .so\ function}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{multiply_8cpp_ad8d9ee68852e46ad9115ffae3bb0bc0b}{multiply}}(\&x,\ \&y);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ geometry\_msgs::PointStamped\ marker\_center;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ marker\_center.header.stamp\ =\ ros::Time::now();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ marker\_center.point.x\ =\ x;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ marker\_center.point.y\ =\ y;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ marker\_center\_pub.publish(marker\_center);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \}}

\end{DoxyCodeInclude}
 Una vez que las coordenadas se publican en el topic, otros nodos de ROS pueden suscribirse a este topic y recibir las coordenadas actualizadas en tiempo real. Esto permite la integración con otros componentes del sistema o la realización de acciones específicas basadas en las coordenadas detectadas. 
\end{DoxyEnumerate}\hypertarget{index_steps_sec5}{}\doxysection{\texorpdfstring{Paso 5\+: Desarrollo de un Wrapper de g\+RPC para convertir el ROS Topic en un servicio RPC}{Paso 5: Desarrollo de un Wrapper de gRPC para convertir el ROS Topic en un servicio RPC}}\label{index_steps_sec5}
En este paso del proyecto, se desarrolla un Wrapper de g\+RPC que convierte el ROS Topic de las coordenadas en un servicio RPC. Esto permite la comunicación entre el nodo ROS y otros programas o sistemas que pueden consumir el servicio RPC.

El Wrapper de g\+RPC se implementa utilizando el lenguaje de programación Python y las bibliotecas de g\+RPC y ROS. A continuación, se describe el flujo de trabajo para convertir el ROS Topic en un servicio RPC utilizando el Wrapper de g\+RPC\+:
\begin{DoxyEnumerate}
\item Definir el servicio RPC\+: Antes de implementar el Wrapper de g\+RPC, se debe definir el servicio RPC que se proporcionará. El servicio debe tener una interfaz clara que especifique los métodos que estarán disponibles y los tipos de datos que se utilizarán. Para esto, se utiliza la herramienta {\ttfamily protoc} para definir el mensaje enviado por g\+RPC. El archivo {\ttfamily .proto} contiene la definición del mensaje y se utiliza para generar los archivos de código necesarios. A continuación se puede observar el archivo {\ttfamily .proto} usado en este proyecto {\ttfamily \doxylink{proto_2PositionService_8proto}{pycam/proto/\+Position\+Service.\+proto}}\+: \begin{DoxyVerb} syntax = "proto3";
 
 package object_position;
 message Empty {
 }
  // El mensaje de respuesta que contiene la posición
  message Position {
    double x = 1;
    double y = 2;
    int64 timestamp = 3; // Este campo representa el timestamp del mensaje.
  }
 
  // La definición del servicio
  service PositionService {
    // Envía una posición
    rpc SendPosition (Empty) returns (Position);
  }
\end{DoxyVerb}

\item Generar los archivos de código\+: Utilizando el compilador de g\+RPC y el archivo {\ttfamily .proto}, se deben generar los archivos de código necesarios para implementar el servicio RPC. Estos archivos incluyen los stubs del cliente y del servidor, así como los mensajes definidos en el servicio. Para generar los archivos se utilizo el siguiente comando\+: \begin{DoxyVerb}$ python -m grpc_tools.protoc --python_out=. --grpc_python_out=. nombre_del_archivo.proto
\end{DoxyVerb}
 Y obtuvimos los archivos {\ttfamily \doxylink{PositionService__pb2_8py}{Position\+Service\+\_\+pb2.\+py}} y {\ttfamily \doxylink{PositionService__pb2__grpc_8py}{Position\+Service\+\_\+pb2\+\_\+grpc.\+py}} que se pueden ver en la carpeta {\ttfamily pycam/src/}.
\item Configurar y ejecutar el wrapper g\+RPC\+: Se crea un wrapper cuya función es configurar el servidor g\+RPC para que escuche en un puerto específico y acepte conexiones entrantes. Y ademas el wrapper va acruat om un nodo de ros el cual se va a subscribir al topico de posición para siempre tener el valor mas actualizado. De esta manera cuando un cliente quiere obtener la posición del objeto, el wrapper le va a devolver la posición que tiene guardada en el momento. Se puede observar el codigo implementado en el archivo {\ttfamily \doxylink{grpc__wrapper_8py}{grpc\+\_\+wrapper.\+py}}\+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{\#!/usr/bin/env\ python3}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{\textcolor{stringliteral}{@file\ grpc\_wrapper.py}}
\DoxyCodeLine{\textcolor{stringliteral}{@author\ Ian\ De\ La\ Garza}}
\DoxyCodeLine{\textcolor{stringliteral}{@date\ 28\ de\ mayo\ de\ 2023}}
\DoxyCodeLine{\textcolor{stringliteral}{@brief\ Este\ archivo\ contiene\ la\ clase\ PositionServiceServicer\ que\ }}
\DoxyCodeLine{\textcolor{stringliteral}{sirve\ como\ servidor\ para\ enviar\ datos\ de\ posición\ a\ través\ de\ gRPC.}}
\DoxyCodeLine{\textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{import}\ time}
\DoxyCodeLine{\textcolor{keyword}{from}\ concurrent\ \textcolor{keyword}{import}\ futures}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{import}\ grpc}
\DoxyCodeLine{\textcolor{keyword}{import}\ rospy}
\DoxyCodeLine{\textcolor{keyword}{from}\ geometry\_msgs.msg\ \textcolor{keyword}{import}\ PointStamped}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{import}\ PositionService\_pb2}
\DoxyCodeLine{\textcolor{keyword}{import}\ PositionService\_pb2\_grpc}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class\ }PositionServiceServicer(\mbox{\hyperlink{classPositionService__pb2__grpc_1_1PositionServiceServicer}{PositionService\_pb2\_grpc.PositionServiceServicer}}):}
\DoxyCodeLine{\ \ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ }\textcolor{preprocessor}{@brief}\ Servidor\ gRPC\ que\ transmite\ datos\ de\ posición.}
\DoxyCodeLine{\ \ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ }\textcolor{keyword}{def\ }\_\_init\_\_(self):}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \ \ \ \ }\textcolor{preprocessor}{@brief}\ Inicializa\ el\ nodo\ ROS,\ se\ suscribe\ a\ \textcolor{stringliteral}{"{}/camera/marker\_center"{}}\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ y\ configura\ el\ servidor\ gRPC.}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \ \ \ \ }}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \ \ \ \ self.latest\_message\ =\ PointStamped()}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \ \ \ \ rospy.init\_node('position\_listener'},\ anonymous=\textcolor{keyword}{True})}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ rospy.Subscriber(\textcolor{stringliteral}{"{}/camera/marker\_center"{}},\ PointStamped,\ self.callback)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ self.server\ =\ grpc.server(futures.ThreadPoolExecutor(max\_workers=10))}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{def\ }callback(self,\ data):}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \ \ \ \ }\textcolor{preprocessor}{@brief}\ Callback\ para\ el\ suscriptor\ ROS,\ actualiza\ el\ mensaje\ más\ reciente.}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{preprocessor}{@param}\ data\ El\ nuevo\ mensaje\ de\ posición\ a\ guardar.}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{\textcolor{stringliteral}{}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \ \ \ \ self.latest\_message\ =\ data}}
\DoxyCodeLine{\textcolor{stringliteral}{}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ }\textcolor{keyword}{def\ }SendPosition(self,\ empty,\ context):}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \ \ \ \ }\textcolor{preprocessor}{@brief}\ Envía\ los\ datos\ de\ posición\ actuales\ a\ través\ de\ gRPC.}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{preprocessor}{@param}\ empty\ El\ objeto\ vacío\ enviado\ por\ el\ cliente,\ no\ se\ utiliza.}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{preprocessor}{@param}\ context\ El\ contexto\ gRPC,\ no\ se\ utiliza.}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{preprocessor}{@return}\ Una\ respuesta\ de\ posición\ que\ contiene\ los\ datos\ de\ posición\ más\ recientes.}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \ \ \ \ }\textcolor{keywordflow}{if}\ self.latest\_message\ \textcolor{keywordflow}{is}\ \textcolor{keywordflow}{not}\ \textcolor{keywordtype}{None}:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ response\ =\ PositionService\_pb2.Position()}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ response.x\ =\ self.latest\_message.point.x}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ response.y\ =\ self.latest\_message.point.y}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ response.timestamp\ =\ self.latest\_message.header.stamp.nsecs}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ response}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ grpc.RpcError(\textcolor{stringliteral}{"{}No\ position\ data\ received\ yet"{}})}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{def\ }serve(self):}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \ \ \ \ }\textcolor{preprocessor}{@brief}\ Inicia\ el\ servidor\ gRPC.}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \ \ \ \ \mbox{\hyperlink{namespacePositionService__pb2__grpc_ad7a61e046f4995370d5de21ed6992798}{PositionService\_pb2\_grpc.add\_PositionServiceServicer\_to\_server}}(self,\ self.server)}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \ \ \ \ self.server.add\_insecure\_port('[::]:50051'})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ self.server.start()}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{def\ }serverStop(self):}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \ \ \ \ }\textcolor{preprocessor}{@brief}\ Detiene\ el\ servidor\ gRPC.}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \ \ \ \ self.server.stop(0)}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ }}
\DoxyCodeLine{\textcolor{stringliteral}{}}
\DoxyCodeLine{\textcolor{stringliteral}{}}
\DoxyCodeLine{\textcolor{stringliteral}{}\textcolor{keywordflow}{if}\ \_\_name\_\_\ ==\ \textcolor{stringliteral}{'\_\_main\_\_'}:}
\DoxyCodeLine{\ \ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ }\textcolor{preprocessor}{@brief}\ El\ punto\ de\ entrada\ del\ programa.\ }
\DoxyCodeLine{\ \ \ \ Se\ crea\ una\ instancia\ de\ PositionServiceServicer\ y\ se\ inicia\ el\ servidor\ gRPC.}
\DoxyCodeLine{\ \ \ \ Cuando\ se\ interrumpe\ el\ programa\ (p.ej.,\ se\ presiona\ Ctrl+C),\ se\ detiene\ el\ servidor\ gRPC.}
\DoxyCodeLine{\ \ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{\textcolor{stringliteral}{}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ }}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ servicer\ =\ PositionServiceServicer()}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ servicer.serve()}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ }\textcolor{keywordflow}{try}:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ rospy.spin()}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{except}\ KeyboardInterrupt:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ servicer.serverStop()}

\end{DoxyCodeInclude}

\end{DoxyEnumerate}

Una vez que se ha implementado el Wrapper de g\+RPC y configurado el servidor, otros programas o sistemas pueden consumir el servicio RPC para obtener las coordenadas del objeto. Esto permite la integración con diferentes plataformas y la comunicación eficiente de las coordenadas.\hypertarget{index_steps_sec56}{}\doxysection{\texorpdfstring{Paso 6\+: Implementación de un programa en Java que consume el servicio RPC y muestra las coordenadas en la terminal}{Paso 6: Implementación de un programa en Java que consume el servicio RPC y muestra las coordenadas en la terminal}}\label{index_steps_sec56}
En este paso del proyecto, se implementa un programa en Java que consume el servicio RPC generado en el paso anterior y muestra las coordenadas del objeto en la terminal.

A continuación, se describe el flujo de trabajo para implementar el programa en Java que consume el servicio RPC\+:


\begin{DoxyEnumerate}
\item Configurar el entorno de desarrollo\+: Antes de comenzar, nos aseguramos de tener instalado el entorno de desarrollo de Java, como JDK (Java Development Kit) y un IDE (Integrated Development Environment) en nuestro caso usamos Visual Studio Code.
\item Importar el código generado\+: Importamos los archivos de código generados por el compilador de g\+RPC en el proyecto Java. Estos archivos incluyen los stubs del cliente y los mensajes definidos en el servicio RPC. Utilizamos Maven para manejar las dependencias y compilar el archivo .proto en el proyecto de Java.
\item Configurar la conexión al servicio RPC\+: En el programa Java, configuramos la conexión al servicio RPC proporcionando la dirección y el puerto del servidor g\+RPC. Se utilizo los stubs del cliente generados para establecer la conexión y crear un cliente g\+RPC.
\item Llamar al método del servicio RPC\+: Utilizando el cliente g\+RPC, llamamos el método del servicio RPC que devuelve las coordenadas del objeto. Pasa los parámetros necesarios según la definición del servicio y captura la respuesta del servidor.
\item Procesar la respuesta y mostrar las coordenadas\+: Procesamos la respuesta recibida del servidor g\+RPC y muestra las coordenadas del objeto en la terminal, en el formato deseado.
\end{DoxyEnumerate}

El codigo se puede observar en el archivo {\ttfamily \doxylink{App_8java}{App.\+java}}\+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{keyword}{package\ }com.example;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{import}\ com.google.protobuf.Empty;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{import}\ io.grpc.ManagedChannel;}
\DoxyCodeLine{\textcolor{keyword}{import}\ io.grpc.ManagedChannelBuilder;}
\DoxyCodeLine{\textcolor{keyword}{import}\ \mbox{\hyperlink{namespaceobject__position}{object\_position}}.\mbox{\hyperlink{classobject__position_1_1PositionServiceGrpc}{PositionServiceGrpc}};}
\DoxyCodeLine{\textcolor{keyword}{import}\ \mbox{\hyperlink{namespaceobject__position}{object\_position}}.\mbox{\hyperlink{classobject__position_1_1PositionServiceOuterClass}{PositionServiceOuterClass}}.\mbox{\hyperlink{classobject__position_1_1PositionServiceOuterClass_1_1Position}{Position}};}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{class\ }App\ }
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classcom_1_1example_1_1App_a28228b12da000bb30a163d24a7c43c35}{main}}(String[]\ args)\ \textcolor{keywordflow}{throws}\ Exception\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ManagedChannel\ channel\ =\ ManagedChannelBuilder.forTarget(\textcolor{stringliteral}{"{}192.168.55.1:50051"{}})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ .usePlaintext()}
\DoxyCodeLine{\ \ \ \ \ \ \ \ .build();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Reemplace\ 'MyServiceGrpc'\ y\ 'MyRequest'\ con\ los\ nombres\ de\ tu\ servicio\ y\ tu\ mensaje.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ PositionServiceGrpc.PositionServiceBlockingStub\ stub\ =\ PositionServiceGrpc.newBlockingStub(channel);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{try}\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}(\textcolor{keyword}{true})\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Position\ response\ =\ stub.sendPosition(\textcolor{keyword}{null});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ System.out.println(\textcolor{stringliteral}{"{}Response\ x:\ "{}}\ +\ response.getX()\ +\ \textcolor{stringliteral}{"{}Response\ y:\ "{}}\ +\ response.getY()\ +\ \textcolor{stringliteral}{"{}\ Timestamp:\ "{}}\ +\ response.getTimestamp());}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Thread.sleep(10);\ \ \textcolor{comment}{//\ Add\ delay\ of\ 1\ second\ between\ each\ request}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{catch}\ (InterruptedException\ e)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ System.out.println(\textcolor{stringliteral}{"{}Shutting\ down\ due\ to\ user\ request."{}});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{finally}\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ channel.shutdown();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}

\end{DoxyCodeInclude}
\hypertarget{index_steps_sec7}{}\doxysection{\texorpdfstring{Paso 7\+: Uso de grpc-\/\+Gateway para exponer el servicio como un REST-\/\+API}{Paso 7: Uso de grpc-Gateway para exponer el servicio como un REST-API}}\label{index_steps_sec7}
En este paso del proyecto, se utiliza grpc-\/\+Gateway para exponer el servicio RPC generado anteriormente como un REST-\/\+API. Esto permite a otros sistemas o aplicaciones consumir el servicio RPC utilizando protocolos RESTful estándar.

A continuación, se describe el flujo de trabajo para utilizar grpc-\/\+Gateway y exponer el servicio RPC como un REST-\/\+API\+:


\begin{DoxyEnumerate}
\item Configurar grpc-\/\+Gateway\+: Antes de comenzar, instalamos el entorno de desarrollo, se utilizo el github oficial de grpc-\/\+Gateway para obtener instrucciones sobre cómo instalarlo.
\item Definir el archivo de configuración\+: Generamos una copia del archivo proto y creamos otro arhivo configuración proto pero le agregamos las especificaciones de la configuración del gateway. En este archivo se definio cómo se mapean los endpoints REST a los métodos del servicio RPC. A continuación se puede observar el archivo {\ttfamily .proto} usado en este proyecto {\ttfamily \doxylink{PositionServiceGo_8proto}{go/position\+Gateway/\+Position\+Service\+Go.\+proto}}\+: \begin{DoxyVerb}syntax = "proto3";

package object_position;
option go_package = ".";
import "google/api/annotations.proto";

message Empty {
}
// The response message containing the greetings
message Position {
  double x = 1;
  double y = 2;
  int64 timestamp = 3; // timestamp as UNIX epoch time
}

// The service definition.
service PositionService {
  // Sends a greeting
  rpc SendPosition (Empty) returns (Position){
    option (google.api.http) = {
      get: "/position"
    };
  }
}
\end{DoxyVerb}

\item Generar el servidor proxy\+: Utilizando el compilador de grpc-\/\+Gateway, generamoos el código del servidor proxy que actuará como intermediario entre las solicitudes REST y el servicio RPC. El servidor proxy se encargará de traducir las solicitudes REST a llamadas RPC y viceversa.
\item Implementar el servidor proxy\+: Implementamos el servidor proxy en el lenguaje de Go. El servidor proxy debe configurarse para escuchar en un puerto específico y gestionar las solicitudes REST entrantes.
\end{DoxyEnumerate}

La implementación del servidor proxy se puede observar en el archivo {\ttfamily go/main.\+go}\+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{package\ main}
\DoxyCodeLine{}
\DoxyCodeLine{import\ (}
\DoxyCodeLine{\ \ \ \ "{}context"{}}
\DoxyCodeLine{\ \ \ \ "{}log"{}}
\DoxyCodeLine{\ \ \ \ "{}net/http"{}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ "{}google.golang.org/grpc"{}}
\DoxyCodeLine{\ \ \ \ "{}github.com/grpc-\/ecosystem/grpc-\/gateway/v2/runtime"{}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ pb\ "{}positionGate/positionGateway"{}}
\DoxyCodeLine{)}
\DoxyCodeLine{}
\DoxyCodeLine{func\ main()\ \{}
\DoxyCodeLine{\ \ \ \ ctx\ :=\ context.Background()}
\DoxyCodeLine{\ \ \ \ mux\ :=\ runtime.NewServeMux()}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ Create\ a\ gRPC\ connection\ to\ your\ existing\ Python\ gRPC\ server}
\DoxyCodeLine{\ \ \ \ grpcServerEndpoint\ :=\ "{}localhost:50051"{}\ //\ Replace\ with\ the\ actual\ address\ of\ your\ Python\ gRPC\ server}
\DoxyCodeLine{\ \ \ \ opts\ :=\ []grpc.DialOption\{grpc.WithInsecure()\}}
\DoxyCodeLine{\ \ \ \ err\ :=\ pb.RegisterPositionServiceHandlerFromEndpoint(ctx,\ mux,\ grpcServerEndpoint,\ opts)}
\DoxyCodeLine{\ \ \ \ if\ err\ !=\ nil\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ log.Fatalf("{}failed\ to\ register\ gateway:\ \%v"{},\ err)}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ Start\ the\ HTTP\ server}
\DoxyCodeLine{\ \ \ \ httpAddr\ :=\ "{}:8080"{}\ //\ Set\ the\ listening\ address\ for\ the\ gateway\ server}
\DoxyCodeLine{\ \ \ \ log.Printf("{}gRPC\ gateway\ server\ listening\ on\ \%s"{},\ httpAddr)}
\DoxyCodeLine{\ \ \ \ if\ err\ :=\ http.ListenAndServe(httpAddr,\ mux);\ err\ !=\ nil\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ log.Fatalf("{}failed\ to\ serve:\ \%v"{},\ err)}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCodeInclude}



\begin{DoxyEnumerate}
\item Ejecutar el servidor proxy\+: Inicia el servidor proxy y asegúrate de que esté en funcionamiento y escuchando en el puerto especificado. Puedes probar el servidor proxy enviando solicitudes REST utilizando herramientas como c\+URL o Postman y verificar las respuestas recibidas.
\end{DoxyEnumerate}

Si quiere ver el servidor proxy funcionando puedes ver el video de la demostración del proyecto que esta al inicio.\hypertarget{index_steps_sec8}{}\doxysection{\texorpdfstring{Paso 8\+:  Adquisición de las coordenadas del objeto desde el nuevo REST-\/\+API utilizando Postman o Flask, y guardar los datos en un archivo JSON}{Paso 8:  Adquisición de las coordenadas del objeto desde el nuevo REST-API utilizando Postman o Flask, y guardar los datos en un archivo JSON}}\label{index_steps_sec8}
A continuación, se describe el flujo de trabajo para adquirir las coordenadas del objeto utilizando Postman o Flask\+:


\begin{DoxyEnumerate}
\item Configurar el entorno\+: Insalamos Postman. Postman es una herramienta de desarrollo de API que permite enviar solicitudes HTTP y recibir respuestas.
\item Crear una solicitud HTTP\+: Utilizando Postman, creamos una solicitud HTTP a la ruta específica del REST-\/\+API que proporciona las coordenadas del objeto.
\item Enviar la solicitud\+: Envíamos la solicitud HTTP al REST-\/\+API y esperamos la respuesta. Se puede ver la respuesta directamente en la interfaz de Postman.
\item Guardar los datos en un archivo JSON\+: Una vez recibido la respuesta del REST-\/\+API, extramos los datos de coordenadas del objeto y guardarlos en un archivo JSON. 
\end{DoxyEnumerate}